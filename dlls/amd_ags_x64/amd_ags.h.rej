--- dlls/amd_ags_x64/amd_ags.h
+++ dlls/amd_ags_x64/amd_ags.h
@@ -96,8 +96,7 @@
 extern "C" {
 #endif
 
-
-#define AMD_AGS_API __declspec(dllexport)   ///< AGS calling convention
+#define AMD_AGS_API WINAPI
 
 // Forward declaration of D3D11 types
 struct IDXGIAdapter;
@@ -117,8 +116,6 @@ struct D3D11_TEXTURE1D_DESC;
 struct D3D11_TEXTURE2D_DESC;
 struct D3D11_TEXTURE3D_DESC;
 struct D3D11_SUBRESOURCE_DATA;
-struct tagRECT;
-typedef tagRECT D3D11_RECT;             ///< typedef this ourselves so we don't have to drag d3d11.h in
 
 // Forward declaration of D3D12 types
 struct ID3D12Device;
@@ -126,7 +123,7 @@ struct ID3D12GraphicsCommandList;
 
 
 /// The return codes
-enum AGSReturnCode
+typedef enum AGSReturnCode
 {
     AGS_SUCCESS,                    ///< Successful function call
     AGS_FAILURE,                    ///< Failed to complete call for some unspecified reason
@@ -136,10 +133,10 @@ enum AGSReturnCode
     AGS_ERROR_LEGACY_DRIVER,        ///< Returned if a feature is not present in the installed driver
     AGS_EXTENSION_NOT_SUPPORTED,    ///< Returned if the driver does not support the requested driver extension
     AGS_ADL_FAILURE,                ///< Failure in ADL (the AMD Display Library)
-};
+} AGSReturnCode;
 
 /// The DirectX11 extension support bits
-enum AGSDriverExtensionDX11
+typedef enum AGSDriverExtensionDX11
 {
     AGS_DX11_EXTENSION_QUADLIST                             = 1 << 0,
     AGS_DX11_EXTENSION_SCREENRECTLIST                       = 1 << 1,
@@ -161,10 +158,10 @@ enum AGSDriverExtensionDX11
     AGS_DX11_EXTENSION_CREATE_SHADER_CONTROLS               = 1 << 17,
     AGS_DX11_EXTENSION_MULTIVIEW                            = 1 << 18,
     AGS_DX11_EXTENSION_APP_REGISTRATION                     = 1 << 19    ///< Supported in Radeon Software Version 17.9.1 onwards.
-};
+} AGSDriverExtensionDX11;
 
 /// The DirectX12 extension support bits
-enum AGSDriverExtensionDX12
+typedef enum AGSDriverExtensionDX12
 {
     AGS_DX12_EXTENSION_INTRINSIC_READFIRSTLANE              = 1 << 0,   ///< Supported in Radeon Software Version 16.9.2 (driver version 16.40.2311) onwards.
     AGS_DX12_EXTENSION_INTRINSIC_READLANE                   = 1 << 1,   ///< Supported in Radeon Software Version 16.9.2 (driver version 16.40.2311) onwards.
@@ -177,48 +174,48 @@ enum AGSDriverExtensionDX12
     AGS_DX12_EXTENSION_INTRINSIC_WAVE_REDUCE                = 1 << 8,   ///< Supported in Radeon Software Version 17.9.1 onwards.
     AGS_DX12_EXTENSION_INTRINSIC_WAVE_SCAN                  = 1 << 9,   ///< Supported in Radeon Software Version 17.9.1 onwards.
     AGS_DX12_EXTENSION_USER_MARKERS                         = 1 << 10   ///< Supported in Radeon Software Version 17.9.1 onwards.
-};
+} AGSDriverExtensionDX12;
 
 /// The space id for DirectX12 intrinsic support
 const unsigned int AGS_DX12_SHADER_INSTRINSICS_SPACE_ID = 0x7FFF0ADE; // 2147420894
 
 
 /// Additional topologies supported via extensions
-enum AGSPrimitiveTopology
+typedef enum AGSPrimitiveTopology
 {
     AGS_PRIMITIVE_TOPOLOGY_QUADLIST                         = 7,
     AGS_PRIMITIVE_TOPOLOGY_SCREENRECTLIST                   = 9
-};
+} AGSPrimitiveTopology;
 
 /// The different modes to control Crossfire behavior.
-enum AGSCrossfireMode
+typedef enum AGSCrossfireMode
 {
     AGS_CROSSFIRE_MODE_DRIVER_AFR = 0,                              ///< Use the default driver-based AFR rendering
     AGS_CROSSFIRE_MODE_EXPLICIT_AFR,                                ///< Use the AGS Crossfire API functions to perform explicit AFR rendering without requiring a CF driver profile
     AGS_CROSSFIRE_MODE_DISABLE                                      ///< Completely disable AFR rendering
-};
+} AGSCrossfireMode;
 
 
 /// The Crossfire API transfer types
-enum AGSAfrTransferType
+typedef enum AGSAfrTransferType
 {
     AGS_AFR_TRANSFER_DEFAULT                                = 0,    ///< Default Crossfire driver resource tracking
     AGS_AFR_TRANSFER_DISABLE                                = 1,    ///< Turn off driver resource tracking
     AGS_AFR_TRANSFER_1STEP_P2P                              = 2,    ///< App controlled GPU to next GPU transfer
     AGS_AFR_TRANSFER_2STEP_NO_BROADCAST                     = 3,    ///< App controlled GPU to next GPU transfer using intermediate system memory
     AGS_AFR_TRANSFER_2STEP_WITH_BROADCAST                   = 4,    ///< App controlled GPU to all render GPUs transfer using intermediate system memory
-};
+} AGSAfrTransferType;
 
 /// The Crossfire API transfer engines
-enum AGSAfrTransferEngine
+typedef enum AGSAfrTransferEngine
 {
     AGS_AFR_TRANSFERENGINE_DEFAULT                          = 0,    ///< Use default engine for Crossfire API transfers
     AGS_AFR_TRANSFERENGINE_3D_ENGINE                        = 1,    ///< Use 3D engine for Crossfire API transfers
     AGS_AFR_TRANSFERENGINE_COPY_ENGINE                      = 2,    ///< Use Copy engine for Crossfire API transfers
-};
+} AGSAfrTransferEngine;
 
 /// The display flags describing various properties of the display.
-enum AGSDisplayFlags
+typedef enum AGSDisplayFlags
 {
     AGS_DISPLAYFLAG_PRIMARY_DISPLAY                         = 1 << 0,   ///< Whether this display is marked as the primary display. Not set on the WACK version.
     AGS_DISPLAYFLAG_HDR10                                   = 1 << 1,   ///< HDR10 is supported on this display
@@ -228,35 +225,33 @@ enum AGSDisplayFlags
     AGS_DISPLAYFLAG_EYEFINITY_IN_GROUP                      = 1 << 5,   ///< The display is part of the Eyefinity group
     AGS_DISPLAYFLAG_EYEFINITY_PREFERRED_DISPLAY             = 1 << 6,   ///< The display is the preferred display in the Eyefinity group for displaying the UI
     AGS_DISPLAYFLAG_EYEFINITY_IN_PORTRAIT_MODE              = 1 << 7,   ///< The display is in the Eyefinity group but in portrait mode
-};
+} AGSDisplayFlags;
 
-struct AGSContext;  ///< All function calls in AGS require a pointer to a context. This is generated via \ref agsInit
+typedef struct AGSContext AGSContext;  ///< All function calls in AGS require a pointer to a context. This is generated via \ref agsInit
 
 /// The rectangle struct used by AGS.
-struct AGSRect
+typedef struct AGSRect
 {
     int offsetX;    ///< Offset on X axis
     int offsetY;    ///< Offset on Y axis
     int width;      ///< Width of rectangle
     int height;     ///< Height of rectangle
-};
+} AGSRect;
 
 /// The clip rectangle struct used by \ref agsDriverExtensionsDX11_SetClipRects
-struct AGSClipRect
+typedef struct AGSClipRect
 {
     /// The inclusion mode for the rect
-    enum Mode
+    enum
     {
         ClipRectIncluded = 0,   ///< Include the rect
         ClipRectExcluded = 1    ///< Exclude the rect
-    };
-
-    Mode            mode; ///< Include/exclude rect region
+    }               mode; ; ///< Include/exclude rect region
     AGSRect         rect; ///< The rect to include/exclude
-};
+} AGSClipRect;
 
 /// The display info struct used to describe a display enumerated by AGS
-struct AGSDisplayInfo
+typedef struct AGSDisplayInfo
 {
     char                    name[ 256 ];                    ///< The name of the display
     char                    displayDeviceName[ 32 ];        ///< The display device name, i.e. DISPLAY_DEVICE::DeviceName
@@ -296,19 +291,19 @@ struct AGSDisplayInfo
 
     int                     logicalDisplayIndex;            ///< The internally used index of this display
     int                     adlAdapterIndex;                ///< The internally used ADL adapter index
-};
+} AGSDisplayInfo;
 
-/// The device info struct used to describe a physical GPU enumerated by AGS
-struct AGSDeviceInfo
+/// The architecture version
+typedef enum ArchitectureVersion
 {
-    /// The architecture version
-    enum ArchitectureVersion
-    {
-        ArchitectureVersion_Unknown,                                ///< Unknown architecture, potentially from another IHV. Check AGSDeviceInfo::vendorId
-        ArchitectureVersion_PreGCN,                                 ///< AMD architecture, pre-GCN
-        ArchitectureVersion_GCN                                     ///< AMD GCN architecture
-    };
+    ArchitectureVersion_Unknown,                                ///< Unknown architecture, potentially from another IHV. Check \ref AGSDeviceInfo::vendorId
+    ArchitectureVersion_PreGCN,                                 ///< AMD architecture, pre-GCN
+    ArchitectureVersion_GCN                                     ///< AMD GCN architecture
+} ArchitectureVersion;
 
+/// The device info struct used to describe a physical GPU enumerated by AGS
+typedef struct AGSDeviceInfo
+{
     ArchitectureVersion             architectureVersion;            ///< Set to Unknown if not AMD hardware
     const char*                     adapterString;                  ///< The adapter name string
     int                             vendorId;                       ///< The vendor id
@@ -334,7 +329,7 @@ struct AGSDeviceInfo
     int                             eyefinityBezelCompensated;      ///< Indicates if bezel compensation is used for the current SLS display area. 1 if enabled, and 0 if disabled.
 
     int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
-};
+} AGSDeviceInfo;
 
 /// \defgroup general General API functions
 /// API for initialization, cleanup, HDR display modes and Crossfire GPU count
@@ -343,16 +338,15 @@ struct AGSDeviceInfo
 typedef void* (__stdcall *AGS_ALLOC_CALLBACK)( int allocationSize );    ///< AGS user defined allocation prototype
 typedef void (__stdcall *AGS_FREE_CALLBACK)( void* allocationPtr );     ///< AGS user defined free prototype
 
-                                                                        /// The configuration options that can be passed in to \ref agsInit
-struct AGSConfiguration
+/// The configuration options that can be passed in to \ref agsInit
+typedef struct AGSConfiguration
 {
     AGS_ALLOC_CALLBACK      allocCallback;                  ///< Optional memory allocation callback. If not supplied, malloc() is used
     AGS_FREE_CALLBACK       freeCallback;                   ///< Optional memory freeing callback. If not supplied, free() is used
-    AGSCrossfireMode        crossfireMode;                  ///< Desired Crossfire mode
-};
+} AGSConfiguration;
 
 /// The top level GPU information returned from \ref agsInit
-struct AGSGPUInfo
+typedef struct AGSGPUInfo
 {
     int                     agsVersionMajor;                ///< Major field of Major.Minor.Patch AGS version number
     int                     agsVersionMinor;                ///< Minor field of Major.Minor.Patch AGS version number
@@ -364,22 +358,20 @@ struct AGSGPUInfo
 
     int                     numDevices;                     ///< Number of GPUs in the system
     AGSDeviceInfo*          devices;                        ///< List of GPUs in the system
-};
+} AGSGPUInfo;
 
 /// The struct to specify the display settings to the driver.
-struct AGSDisplaySettings
+typedef struct AGSDisplaySettings
 {
     /// The display mode
-    enum Mode
+    enum
     {
         Mode_SDR,                                           ///< SDR mode
         Mode_HDR10_PQ,                                      ///< HDR10 PQ encoding, requiring a 1010102 UNORM swapchain and PQ encoding in the output shader.
         Mode_HDR10_scRGB,                                   ///< HDR10 scRGB, requiring an FP16 swapchain. Values of 1.0 == 80 nits, 125.0 == 10000 nits.
         Mode_Freesync2_scRGB,                               ///< Freesync2 scRGB, requiring an FP16 swapchain. Values in the range of 0.0 to 125.0 where 125.0 == AGSDisplayInfo::maxLuminance.
         Mode_DolbyVision                                    ///< Dolby Vision, requiring an 8888 UNORM swapchain
-    };
-
-    Mode                    mode;                           ///< The display mode to set the display into
+    }                       mode;                           ///< The display mode to set the display into
 
     double                  chromaticityRedX;               ///< Red display primary X coord
     double                  chromaticityRedY;               ///< Red display primary Y coord
@@ -398,7 +390,7 @@ struct AGSDisplaySettings
 
     double                  maxContentLightLevel;           ///< The maximum content light level in nits (MaxCLL)
     double                  maxFrameAverageLightLevel;      ///< The maximum frame average light level in nits (MaxFALL)
-};
+} AGSDisplaySettings;
 
 ///
 /// Function used to initialize the AGS library.
@@ -526,7 +518,7 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_SetMarker( AGSContext* context
 /// @{
 
 /// The struct to specify the existing DX11 device creation parameters
-struct AGSDX11DeviceCreationParams
+typedef struct AGSDX11DeviceCreationParams
 {
     IDXGIAdapter*               pAdapter;                   ///< Consult the DX documentation on D3D11CreateDevice for this parameter
     D3D_DRIVER_TYPE             DriverType;                 ///< Consult the DX documentation on D3D11CreateDevice for this parameter
@@ -536,13 +528,13 @@ struct AGSDX11DeviceCreationParams
     UINT                        FeatureLevels;              ///< Consult the DX documentation on D3D11CreateDevice for this parameter
     UINT                        SDKVersion;                 ///< Consult the DX documentation on D3D11CreateDevice for this parameter
     const DXGI_SWAP_CHAIN_DESC* pSwapChainDesc;             ///< Optional swapchain description. Specify this to invoke D3D11CreateDeviceAndSwapChain instead of D3D11CreateDevice. This must be null on the WACK compliant version
-};
+} AGSDX11DeviceCreationParams;
 
 #define AGS_MAKE_VERSION( major, minor, patch ) ( ( major << 22 ) | ( minor << 12 ) | patch ) ///< Macro to create the app and engine versions for the fields in \ref AGSDX11ExtensionParams
 #define AGS_UNSPECIFIED_VERSION 0xFFFFAD00                                                    ///< Use this to specify no version
 
 /// The struct to specify DX11 additional device creation parameters
-struct AGSDX11ExtensionParams
+typedef struct AGSDX11ExtensionParams
 {
     unsigned int    uavSlot;           ///< The UAV slot reserved for intrinsic support. This must match the slot defined in the HLSL, i.e. #define AmdDxExtShaderIntrinsicsUAVSlot.
                                        /// The default slot is 7, but the caller is free to use an alternative slot.
@@ -550,17 +542,17 @@ struct AGSDX11ExtensionParams
     UINT            appVersion;        ///< Application version
     const WCHAR*    pEngineName;       ///< Engine name
     UINT            engineVersion;     ///< Engine version
-};
+} AGSDX11ExtensionParams;
 
 /// The struct to hold all the returned parameters from the device creation call
-struct AGSDX11ReturnedParams
+typedef struct AGSDX11ReturnedParams
 {
     ID3D11Device*           pDevice;                ///< The newly created device
     D3D_FEATURE_LEVEL       FeatureLevel;           ///< The feature level supported by the newly created device
     ID3D11DeviceContext*    pImmediateContext;      ///< The newly created immediate device context
     IDXGISwapChain*         pSwapChain;             ///< The newly created swap chain. This is only created if a valid pSwapChainDesc is supplied in AGSDX11DeviceCreationParams. This is not supported on the WACK compliant version
     unsigned int            extensionsSupported;    ///< Bit mask that \ref agsDriverExtensionsDX11_CreateDevice will fill in to indicate which extensions are supported. See AGSDriverExtensionDX11
-};
+} AGSDX11ReturnedParams;
 
 ///
 /// Function used to create a D3D11 device with additional AMD-specific initialization parameters.
--- dlls/amd_ags_x64/amd_ags.h
+++ dlls/amd_ags_x64/amd_ags.h
@@ -1,5 +1,5 @@
 //
-// Copyright (c) 2017 Advanced Micro Devices, Inc. All rights reserved.
+// Copyright (c) 2018 Advanced Micro Devices, Inc. All rights reserved.
 //
 // Permission is hereby granted, free of charge, to any person obtaining a copy
 // of this software and associated documentation files (the "Software"), to deal
@@ -24,7 +24,7 @@
 /// \mainpage
 /// AGS Library Overview
 /// --------------------
-/// This document provides an overview of the AGS (AMD GPU Services) library. The AGS library provides software developers with the ability to query
+/// This document provides an overview of the AGS (AMD GPU Services) library. The AGS library provides software developers with the ability to query 
 /// AMD GPU software and hardware state information that is not normally available through standard operating systems or graphic APIs.
 ///
 /// The latest version of the API is publicly hosted here: https://github.com/GPUOpen-LibrariesAndSDKs/AGS_SDK/.
@@ -59,7 +68,7 @@
 ///
 /// What's new in AGS 5.x since version 4.x
 /// ---------------------------------------
-/// Version 5.x is a major overhaul of the library designed to provide a much clearer view of the GPUs in the system and the displays attached to them.
+/// Version 5.x is a major overhaul of the library designed to provide a much clearer view of the GPUs in the system and the displays attached to them. 
 /// It also exposes the ability to query each display for HDR capabilities and put those HDR capable displays into various HDR modes.
 /// Some functions such as agsGetGPUMemorySize and agsGetEyefinityConfigInfo have been removed in favor of including this information in the device & display enumeration.
 /// Features include:
@@ -78,8 +87,8 @@
 /// * AGSSample
 /// * CrossfireSample
 /// * EyefinitySample
-/// The AGSSample application is the simplest of the three examples and demonstrates the code required to initialize AGS and use it to query the GPU and Eyefinity state.
-/// The CrossfireSample application demonstrates the use of the new API to transfer resources on GPUs in Crossfire mode. Lastly, the EyefinitySample application provides a more
+/// The AGSSample application is the simplest of the three examples and demonstrates the code required to initialize AGS and use it to query the GPU and Eyefinity state. 
+/// The CrossfireSample application demonstrates the use of the new API to transfer resources on GPUs in Crossfire mode. Lastly, the EyefinitySample application provides a more 
 /// extensive example of Eyefinity setup than the basic example provided in AGSSample.
 /// There are other samples on Github that demonstrate the DirectX shader extensions, such as the Barycentrics11 and Barycentrics12 samples.
 ///
@@ -89,17 +98,16 @@
 /// * Include the amd_ags.h header file from your source code.
 /// * Include the AGS hlsl files if you are using the shader intrinsics.
 /// * Declare a pointer to an AGSContext and make this available for all subsequent calls to AGS.
-/// * On game initialization, call agsInit() passing in the address of the context. On success, this function will return a valid context pointer.
-/// * The agsInit() function should be called before the D3D device is created if the Crossfire mode is specified.
+/// * On game initialization, call \ref agsInit passing in the address of the context. On success, this function will return a valid context pointer.
 ///
-/// Don't forget to cleanup AGS by calling agsDeInit() when the app exits, after the device has been destroyed.
+/// Don't forget to cleanup AGS by calling \ref agsDeInit when the app exits, after the device has been destroyed.
 
 #ifndef AMD_AGS_H
 #define AMD_AGS_H
 
 #define AMD_AGS_VERSION_MAJOR 5             ///< AGS major version
-#define AMD_AGS_VERSION_MINOR 1             ///< AGS minor version
-#define AMD_AGS_VERSION_PATCH 1             ///< AGS patch version
+#define AMD_AGS_VERSION_MINOR 2             ///< AGS minor version
+#define AMD_AGS_VERSION_PATCH 0             ///< AGS patch version
 
 #ifdef __cplusplus
 extern "C" {
@@ -147,42 +155,44 @@ typedef enum AGSReturnCode
 /// The DirectX11 extension support bits
 typedef enum AGSDriverExtensionDX11
 {
-    AGS_DX11_EXTENSION_QUADLIST                             = 1 << 0,
-    AGS_DX11_EXTENSION_SCREENRECTLIST                       = 1 << 1,
-    AGS_DX11_EXTENSION_UAV_OVERLAP                          = 1 << 2,
-    AGS_DX11_EXTENSION_DEPTH_BOUNDS_TEST                    = 1 << 3,
-    AGS_DX11_EXTENSION_MULTIDRAWINDIRECT                    = 1 << 4,
-    AGS_DX11_EXTENSION_MULTIDRAWINDIRECT_COUNTINDIRECT      = 1 << 5,
-    AGS_DX11_EXTENSION_CROSSFIRE_API                        = 1 << 6,
-    AGS_DX11_EXTENSION_INTRINSIC_READFIRSTLANE              = 1 << 7,
-    AGS_DX11_EXTENSION_INTRINSIC_READLANE                   = 1 << 8,
-    AGS_DX11_EXTENSION_INTRINSIC_LANEID                     = 1 << 9,
-    AGS_DX11_EXTENSION_INTRINSIC_SWIZZLE                    = 1 << 10,
-    AGS_DX11_EXTENSION_INTRINSIC_BALLOT                     = 1 << 11,
-    AGS_DX11_EXTENSION_INTRINSIC_MBCOUNT                    = 1 << 12,
-    AGS_DX11_EXTENSION_INTRINSIC_COMPARE3                   = 1 << 13,
-    AGS_DX11_EXTENSION_INTRINSIC_BARYCENTRICS               = 1 << 14,
+    AGS_DX11_EXTENSION_QUADLIST                             = 1 << 0,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_SCREENRECTLIST                       = 1 << 1,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_UAV_OVERLAP                          = 1 << 2,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_DEPTH_BOUNDS_TEST                    = 1 << 3,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_MULTIDRAWINDIRECT                    = 1 << 4,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_MULTIDRAWINDIRECT_COUNTINDIRECT      = 1 << 5,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_CROSSFIRE_API                        = 1 << 6,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_READFIRSTLANE              = 1 << 7,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_READLANE                   = 1 << 8,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_LANEID                     = 1 << 9,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_SWIZZLE                    = 1 << 10,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_BALLOT                     = 1 << 11,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_MBCOUNT                    = 1 << 12,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_MED3                       = 1 << 13,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_BARYCENTRICS               = 1 << 14,   ///< Supported in Radeon Software Version 16.9.2 onwards.
     AGS_DX11_EXTENSION_INTRINSIC_WAVE_REDUCE                = 1 << 15,   ///< Supported in Radeon Software Version 17.9.1 onwards.
     AGS_DX11_EXTENSION_INTRINSIC_WAVE_SCAN                  = 1 << 16,   ///< Supported in Radeon Software Version 17.9.1 onwards.
-    AGS_DX11_EXTENSION_CREATE_SHADER_CONTROLS               = 1 << 17,
-    AGS_DX11_EXTENSION_MULTIVIEW                            = 1 << 18,
-    AGS_DX11_EXTENSION_APP_REGISTRATION                     = 1 << 19    ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX11_EXTENSION_CREATE_SHADER_CONTROLS               = 1 << 17,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_MULTIVIEW                            = 1 << 18,   ///< Supported in Radeon Software Version 16.12.1 onwards.
+    AGS_DX11_EXTENSION_APP_REGISTRATION                     = 1 << 19,   ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX11_EXTENSION_BREADCRUMB_MARKERS                   = 1 << 20,   ///< Supported in Radeon Software Version 17.11.1 onwards.
 } AGSDriverExtensionDX11;
 
 /// The DirectX12 extension support bits
 typedef enum AGSDriverExtensionDX12
 {
-    AGS_DX12_EXTENSION_INTRINSIC_READFIRSTLANE              = 1 << 0,   ///< Supported in Radeon Software Version 16.9.2 (driver version 16.40.2311) onwards.
-    AGS_DX12_EXTENSION_INTRINSIC_READLANE                   = 1 << 1,   ///< Supported in Radeon Software Version 16.9.2 (driver version 16.40.2311) onwards.
-    AGS_DX12_EXTENSION_INTRINSIC_LANEID                     = 1 << 2,   ///< Supported in Radeon Software Version 16.9.2 (driver version 16.40.2311) onwards.
-    AGS_DX12_EXTENSION_INTRINSIC_SWIZZLE                    = 1 << 3,   ///< Supported in Radeon Software Version 16.9.2 (driver version 16.40.2311) onwards.
-    AGS_DX12_EXTENSION_INTRINSIC_BALLOT                     = 1 << 4,   ///< Supported in Radeon Software Version 16.9.2 (driver version 16.40.2311) onwards.
-    AGS_DX12_EXTENSION_INTRINSIC_MBCOUNT                    = 1 << 5,   ///< Supported in Radeon Software Version 16.9.2 (driver version 16.40.2311) onwards.
-    AGS_DX12_EXTENSION_INTRINSIC_COMPARE3                   = 1 << 6,   ///< Supported in Radeon Software Version 16.9.2 (driver version 16.40.2311) onwards.
-    AGS_DX12_EXTENSION_INTRINSIC_BARYCENTRICS               = 1 << 7,   ///< Supported in Radeon Software Version 16.9.2 (driver version 16.40.2311) onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_READFIRSTLANE              = 1 << 0,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_READLANE                   = 1 << 1,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_LANEID                     = 1 << 2,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_SWIZZLE                    = 1 << 3,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_BALLOT                     = 1 << 4,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_MBCOUNT                    = 1 << 5,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_MED3                       = 1 << 6,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_BARYCENTRICS               = 1 << 7,   ///< Supported in Radeon Software Version 16.9.2 onwards.
     AGS_DX12_EXTENSION_INTRINSIC_WAVE_REDUCE                = 1 << 8,   ///< Supported in Radeon Software Version 17.9.1 onwards.
     AGS_DX12_EXTENSION_INTRINSIC_WAVE_SCAN                  = 1 << 9,   ///< Supported in Radeon Software Version 17.9.1 onwards.
-    AGS_DX12_EXTENSION_USER_MARKERS                         = 1 << 10   ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX12_EXTENSION_USER_MARKERS                         = 1 << 10,  ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX12_EXTENSION_APP_REGISTRATION                     = 1 << 11   ///< Supported in Radeon Software Version 17.9.1 onwards.
 } AGSDriverExtensionDX12;
 
 /// The space id for DirectX12 intrinsic support
@@ -192,37 +202,10 @@ const unsigned int AGS_DX12_SHADER_INSTRINSICS_SPACE_ID = 0x7FFF0ADE; // 2147420
 /// Additional topologies supported via extensions
 typedef enum AGSPrimitiveTopology
 {
-    AGS_PRIMITIVE_TOPOLOGY_QUADLIST                         = 7,
-    AGS_PRIMITIVE_TOPOLOGY_SCREENRECTLIST                   = 9
+    AGS_PRIMITIVE_TOPOLOGY_QUADLIST                         = 7,    ///< Quad list
+    AGS_PRIMITIVE_TOPOLOGY_SCREENRECTLIST                   = 9     ///< Screen rect list
 } AGSPrimitiveTopology;
 
-/// The different modes to control Crossfire behavior.
-typedef enum AGSCrossfireMode
-{
-    AGS_CROSSFIRE_MODE_DRIVER_AFR = 0,                              ///< Use the default driver-based AFR rendering
-    AGS_CROSSFIRE_MODE_EXPLICIT_AFR,                                ///< Use the AGS Crossfire API functions to perform explicit AFR rendering without requiring a CF driver profile
-    AGS_CROSSFIRE_MODE_DISABLE                                      ///< Completely disable AFR rendering
-} AGSCrossfireMode;
-
-
-/// The Crossfire API transfer types
-typedef enum AGSAfrTransferType
-{
-    AGS_AFR_TRANSFER_DEFAULT                                = 0,    ///< Default Crossfire driver resource tracking
-    AGS_AFR_TRANSFER_DISABLE                                = 1,    ///< Turn off driver resource tracking
-    AGS_AFR_TRANSFER_1STEP_P2P                              = 2,    ///< App controlled GPU to next GPU transfer
-    AGS_AFR_TRANSFER_2STEP_NO_BROADCAST                     = 3,    ///< App controlled GPU to next GPU transfer using intermediate system memory
-    AGS_AFR_TRANSFER_2STEP_WITH_BROADCAST                   = 4,    ///< App controlled GPU to all render GPUs transfer using intermediate system memory
-} AGSAfrTransferType;
-
-/// The Crossfire API transfer engines
-typedef enum AGSAfrTransferEngine
-{
-    AGS_AFR_TRANSFERENGINE_DEFAULT                          = 0,    ///< Use default engine for Crossfire API transfers
-    AGS_AFR_TRANSFERENGINE_3D_ENGINE                        = 1,    ///< Use 3D engine for Crossfire API transfers
-    AGS_AFR_TRANSFERENGINE_COPY_ENGINE                      = 2,    ///< Use Copy engine for Crossfire API transfers
-} AGSAfrTransferEngine;
-
 /// The display flags describing various properties of the display.
 typedef enum AGSDisplayFlags
 {
@@ -318,7 +308,7 @@ typedef enum ArchitectureVersion
 } ArchitectureVersion;
 
 /// The device info struct used to describe a physical GPU enumerated by AGS
-typedef struct AGSDeviceInfo
+typedef struct AGSDeviceInfo_511
 {
     ArchitectureVersion             architectureVersion;            ///< Set to Unknown if not AMD hardware
     const char*                     adapterString;                  ///< The adapter name string
@@ -345,20 +335,71 @@ typedef struct AGSDeviceInfo
     int                             eyefinityBezelCompensated;      ///< Indicates if bezel compensation is used for the current SLS display area. 1 if enabled, and 0 if disabled.
 
     int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
+} AGSDeviceInfo_511;
+
+/// The device info struct used to describe a physical GPU enumerated by AGS
+typedef struct AGSDeviceInfo_520
+{
+    const char*                     adapterString;                  ///< The adapter name string
+    ArchitectureVersion             architectureVersion;            ///< Set to Unknown if not AMD hardware
+    int                             vendorId;                       ///< The vendor id
+    int                             deviceId;                       ///< The device id
+    int                             revisionId;                     ///< The revision id
+
+    int                             numCUs;                         ///< Number of compute units. Zero if not GCN onwards
+    int                             numROPs;                        ///< Number of ROPs
+    int                             coreClock;                      ///< Core clock speed at 100% power in MHz
+    int                             memoryClock;                    ///< Memory clock speed at 100% power in MHz
+    int                             memoryBandwidth;                ///< Memory bandwidth in MB/s
+    float                           teraFlops;                      ///< Teraflops of GPU. Zero if not GCN onwards. Calculated from iCoreClock * iNumCUs * 64 Pixels/clk * 2 instructions/MAD
+
+    int                             isPrimaryDevice;                ///< Whether or not this is the primary adapter in the system. Not set on the WACK version.
+    long long                       localMemoryInBytes;             ///< The size of local memory in bytes. 0 for non AMD hardware.
+
+    int                             numDisplays;                    ///< The number of active displays found to be attached to this adapter.
+    AGSDisplayInfo*                 displays;                       ///< List of displays allocated by AGS to be numDisplays in length.
+
+    int                             eyefinityEnabled;               ///< Indicates if Eyefinity is active
+    int                             eyefinityGridWidth;             ///< Contains width of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityGridHeight;            ///< Contains height of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityResolutionX;           ///< Contains width in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityResolutionY;           ///< Contains height in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityBezelCompensated;      ///< Indicates if bezel compensation is used for the current SLS display area. 1 if enabled, and 0 if disabled.
+
+    int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
+} AGSDeviceInfo_520;
+
+typedef union AGSDeviceInfo
+{
+    AGSDeviceInfo_511 agsDeviceInfo511;
+    AGSDeviceInfo_520 agsDeviceInfo520;
 } AGSDeviceInfo;
 
 /// \defgroup general General API functions
 /// API for initialization, cleanup, HDR display modes and Crossfire GPU count
 /// @{
 
-typedef void* (__stdcall *AGS_ALLOC_CALLBACK)( int allocationSize );    ///< AGS user defined allocation prototype
-typedef void (__stdcall *AGS_FREE_CALLBACK)( void* allocationPtr );     ///< AGS user defined free prototype
+typedef void* (__stdcall *AGS_ALLOC_CALLBACK_511)( int allocationSize );    ///< AGS user defined allocation prototype
+typedef void* (__stdcall *AGS_ALLOC_CALLBACK)( size_t allocationSize );     ///< AGS user defined allocation prototype
+typedef void (__stdcall *AGS_FREE_CALLBACK)( void* allocationPtr );         ///< AGS user defined free prototype
 
 /// The configuration options that can be passed in to \ref agsInit
-typedef struct AGSConfiguration
+typedef struct AGSConfiguration_511
+{
+    AGS_ALLOC_CALLBACK_511  allocCallback;                  ///< Optional memory allocation callback. If not supplied, malloc() is used
+    AGS_FREE_CALLBACK       freeCallback;                   ///< Optional memory freeing callback. If not supplied, free() is used
+} AGSConfiguration_511;
+
+typedef struct AGSConfiguration_520
 {
     AGS_ALLOC_CALLBACK      allocCallback;                  ///< Optional memory allocation callback. If not supplied, malloc() is used
     AGS_FREE_CALLBACK       freeCallback;                   ///< Optional memory freeing callback. If not supplied, free() is used
+} AGSConfiguration_520;
+
+typedef union AGSConfiguration
+{
+    AGSConfiguration_511    agsConfiguration511;
+    AGSConfiguration_520    agsConfiguration520;
 } AGSConfiguration;
 
 /// The top level GPU information returned from \ref agsInit
@@ -385,7 +426,7 @@ typedef struct AGSDisplaySettings
         Mode_SDR,                                           ///< SDR mode
         Mode_HDR10_PQ,                                      ///< HDR10 PQ encoding, requiring a 1010102 UNORM swapchain and PQ encoding in the output shader.
         Mode_HDR10_scRGB,                                   ///< HDR10 scRGB, requiring an FP16 swapchain. Values of 1.0 == 80 nits, 125.0 == 10000 nits.
-        Mode_Freesync2_scRGB,                               ///< Freesync2 scRGB, requiring an FP16 swapchain. Values in the range of 0.0 to 125.0 where 125.0 == AGSDisplayInfo::maxLuminance.
+        Mode_Freesync2_scRGB,                               ///< Freesync2 scRGB, requiring an FP16 swapchain. 1.0 == 80 nits. Tonemap your scene to the range of 0.0 to AGSDisplayInfo::maxLuminance.
         Mode_DolbyVision                                    ///< Dolby Vision, requiring an 8888 UNORM swapchain
     }                       mode;                           ///< The display mode to set the display into
 
@@ -406,13 +447,16 @@ typedef struct AGSDisplaySettings
 
     double                  maxContentLightLevel;           ///< The maximum content light level in nits (MaxCLL)
     double                  maxFrameAverageLightLevel;      ///< The maximum frame average light level in nits (MaxFALL)
+
+    // ADDED IN 5.2.0
+    int                     flags;                          ///< Bitfield of ::AGSDisplaySettingsFlags
 } AGSDisplaySettings;
 
 ///
 /// Function used to initialize the AGS library.
 /// Must be called prior to any of the subsequent AGS API calls.
 /// Must be called prior to ID3D11Device or ID3D12Device creation.
-/// \note This function will fail with AGS_ERROR_LEGACY_DRIVER in Catalyst versions before 12.20.
+/// \note This function will fail with \ref AGS_ERROR_LEGACY_DRIVER in Catalyst versions before 12.20.
 /// \note It is good practice to check the AGS version returned from AGSGPUInfo against the version defined in the header in case a mismatch between the dll and header has occurred.
 ///
 /// \param [in, out] context                        Address of a pointer to a context. This function allocates a context on the heap which is then required for all subsequent API calls.
@@ -435,6 +479,7 @@ AMD_AGS_API AGSReturnCode agsDeInit( AGSContext* context );
 /// \param [in] context                             Pointer to a context.
 /// \param [out] numGPUs                            Number of GPUs used for Crossfire acceleration
 ///
+/// REMOVED IN 5.2.0
 AMD_AGS_API AGSReturnCode agsGetCrossfireGPUCount( AGSContext* context, int* numGPUs );
 
 ///
@@ -443,7 +488,6 @@ AMD_AGS_API AGSReturnCode agsGetCrossfireGPUCount( AGSContext* context, int* num
 /// \note Call this function after each mode change (switch to fullscreen, any change in swapchain etc).
 /// \note HDR10 PQ mode requires a 1010102 swapchain.
 /// \note HDR10 scRGB mode requires an FP16 swapchain.
-/// \note Freesync2 Gamma mode requires a 1010102 swapchain.
 /// \note Freesync2 scRGB mode requires an FP16 swapchain.
 /// \note Dolby Vision requires a 8888 UNORM swapchain.
 ///
@@ -460,9 +504,65 @@ AMD_AGS_API AGSReturnCode agsSetDisplayMode( AGSContext* context, int deviceInde
 /// DirectX12 driver extensions
 /// @{
 
-/// \defgroup dx12init Initialization and Cleanup
+/// \defgroup dx12init Device creation and cleanup
+/// It is now mandatory to call \ref agsDriverExtensionsDX12_CreateDevice when creating a device if the user wants to access any future DX12 AMD extensions.
+/// The corresponding \ref agsDriverExtensionsDX12_DestroyDevice call must be called to release the device and free up the internal resources allocated by the create call.
 /// @{
 
+/// The struct to specify the DX12 device creation parameters
+typedef struct AGSDX12DeviceCreationParams
+{
+    IDXGIAdapter*               pAdapter;                   ///< Pointer to the adapter to use when creating the device.  This may be null.
+    IID                         iid;                        ///< The interface ID for the type of device to be created.
+    D3D_FEATURE_LEVEL           FeatureLevel;               ///< The minimum feature level to create the device with.
+} AGSDX12DeviceCreationParams;
+
+#define AGS_MAKE_VERSION( major, minor, patch ) ( ( major << 22 ) | ( minor << 12 ) | patch ) ///< Macro to create the app and engine versions for the fields in \ref AGSDX12ExtensionParams and \ref AGSDX11ExtensionParams
+#define AGS_UNSPECIFIED_VERSION 0xFFFFAD00                                                    ///< Use this to specify no version
+
+/// The struct to specify DX12 additional device creation parameters
+typedef struct AGSDX12ExtensionParams
+{
+    const WCHAR*    pAppName;               ///< Application name
+    const WCHAR*    pEngineName;            ///< Engine name
+    unsigned int    appVersion;             ///< Application version
+    unsigned int    engineVersion;          ///< Engine version
+} AGSDX12ExtensionParams;
+
+/// The struct to hold all the returned parameters from the device creation call
+typedef struct AGSDX12ReturnedParams
+{
+    ID3D12Device*           pDevice;                ///< The newly created device
+    unsigned int            extensionsSupported;    ///< Bit mask that \ref agsDriverExtensionsDX12_CreateDevice will fill in to indicate which extensions are supported. See \ref AGSDriverExtensionDX12
+} AGSDX12ReturnedParams;
+
+
+///
+/// Function used to create a D3D12 device with additional AMD-specific initialization parameters.
+///
+/// When using the HLSL shader extensions please note:
+/// * The shader compiler should not use the D3DCOMPILE_SKIP_OPTIMIZATION (/Od) option, otherwise it will not work.
+/// * The shader compiler needs D3DCOMPILE_ENABLE_STRICTNESS (/Ges) enabled.
+/// * The intrinsic instructions require a 5.1 shader model.
+/// * The Root Signature will need to use an extra resource and sampler. These are not real resources/samplers, they are just used to encode the intrinsic instruction.
+///
+/// \param [in] context                             Pointer to a context. This is generated by \ref agsInit
+/// \param [in] creationParams                      Pointer to the struct to specify the existing DX12 device creation parameters.
+/// \param [in] extensionParams                     Optional pointer to the struct to specify DX12 additional device creation parameters.
+/// \param [out] returnedParams                     Pointer to struct to hold all the returned parameters from the call.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_CreateDevice( AGSContext* context, const AGSDX12DeviceCreationParams* creationParams, const AGSDX12ExtensionParams* extensionParams, AGSDX12ReturnedParams* returnedParams );
+
+///
+/// Function to destroy the D3D12 device.
+/// This call will also cleanup any AMD-specific driver extensions for D3D12.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] device                              Pointer to the D3D12 device.
+/// \param [out] deviceReferences                   Optional pointer to an unsigned int that will be set to the value returned from device->Release().
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_DestroyDevice( AGSContext* context, ID3D12Device* device, unsigned int* deviceReferences );
+
 ///
 /// Function used to initialize the AMD-specific driver extensions for D3D12.
 /// Extensions require support in the driver, therefore it is important to check the extensionsSupported bitfield.
@@ -476,6 +576,7 @@ AMD_AGS_API AGSReturnCode agsSetDisplayMode( AGSContext* context, int deviceInde
 /// \param [in] device                              The D3D12 device.
 /// \param [out] extensionsSupported                Pointer to a bit mask that this function will fill in to indicate which extensions are supported. See ::AGSDriverExtensionDX12
 ///
+/// REMOVED IN 5.2.0
 AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_Init( AGSContext* context, ID3D12Device* device, unsigned int* extensionsSupported );
 
 ///
@@ -483,6 +584,7 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_Init( AGSContext* context, ID3
 ///
 /// \param [in] context                             Pointer to a context.
 ///
+/// REMOVED IN 5.2.0
 AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_DeInit( AGSContext* context );
 
 /// @}
@@ -492,7 +594,7 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_DeInit( AGSContext* context );
 
 ///
 /// Function used to push an AMD user marker onto the command list.
-/// This is only has an effect if AGS_DX12_EXTENSION_USER_MARKERS is present in the extensionsSupported bitfield of agsDriverExtensionsDX12_Init()
+/// This is only has an effect if AGS_DX12_EXTENSION_USER_MARKERS is present in the extensionsSupported bitfield of \ref agsDriverExtensionsDX12_CreateDevice
 /// Supported in Radeon Software Version 17.9.1 onwards.
 ///
 /// \param [in] context                             Pointer to a context.
@@ -529,10 +631,18 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_SetMarker( AGSContext* context
 /// @{
 
 /// \defgroup dx11init Device creation and cleanup
-/// It is now mandatory to call agsDriverExtensionsDX11_CreateDevice() when creating a device if the user wants to access any DX11 AMD extensions.
-/// The corresponding agsDriverExtensionsDX11_DestroyDevice() call must be called to release the device and free up the internal resources allocated by the create call.
+/// It is now mandatory to call \ref agsDriverExtensionsDX11_CreateDevice when creating a device if the user wants to access any DX11 AMD extensions.
+/// The corresponding \ref agsDriverExtensionsDX11_DestroyDevice call must be called to release the device and free up the internal resources allocated by the create call.
 /// @{
 
+/// The different modes to control Crossfire behavior.
+typedef enum AGSCrossfireMode
+{
+    AGS_CROSSFIRE_MODE_DRIVER_AFR = 0,                      ///< Use the default driver-based AFR rendering
+    AGS_CROSSFIRE_MODE_EXPLICIT_AFR,                        ///< Use the AGS Crossfire API functions to perform explicit AFR rendering without requiring a CF driver profile
+    AGS_CROSSFIRE_MODE_DISABLE                              ///< Completely disable AFR rendering
+} AGSCrossfireMode;
+
 /// The struct to specify the existing DX11 device creation parameters
 typedef struct AGSDX11DeviceCreationParams
 {
@@ -546,11 +656,8 @@ typedef struct AGSDX11DeviceCreationParams
     const DXGI_SWAP_CHAIN_DESC* pSwapChainDesc;             ///< Optional swapchain description. Specify this to invoke D3D11CreateDeviceAndSwapChain instead of D3D11CreateDevice. This must be null on the WACK compliant version
 } AGSDX11DeviceCreationParams;
 
-#define AGS_MAKE_VERSION( major, minor, patch ) ( ( major << 22 ) | ( minor << 12 ) | patch ) ///< Macro to create the app and engine versions for the fields in \ref AGSDX11ExtensionParams
-#define AGS_UNSPECIFIED_VERSION 0xFFFFAD00                                                    ///< Use this to specify no version
-
 /// The struct to specify DX11 additional device creation parameters
-typedef struct AGSDX11ExtensionParams
+typedef struct AGSDX11ExtensionParams_511
 {
     unsigned int    uavSlot;           ///< The UAV slot reserved for intrinsic support. This must match the slot defined in the HLSL, i.e. #define AmdDxExtShaderIntrinsicsUAVSlot.
                                        /// The default slot is 7, but the caller is free to use an alternative slot.
@@ -558,30 +665,80 @@ typedef struct AGSDX11ExtensionParams
     UINT            appVersion;        ///< Application version
     const WCHAR*    pEngineName;       ///< Engine name
     UINT            engineVersion;     ///< Engine version
+} AGSDX11ExtensionParams_511;
+
+typedef struct AGSDX11ExtensionParams_520
+{
+    const WCHAR*                pAppName;                   ///< Application name
+    const WCHAR*                pEngineName;                ///< Engine name
+    unsigned int                appVersion;                 ///< Application version
+    unsigned int                engineVersion;              ///< Engine version
+    unsigned int                numBreadcrumbMarkers;       ///< The number of breadcrumb markers to allocate. Each marker is a uint64 (ie 8 bytes). If 0, the system is disabled.
+    unsigned int                uavSlot;                    ///< The UAV slot reserved for intrinsic support. This must match the slot defined in the HLSL, i.e. "#define AmdDxExtShaderIntrinsicsUAVSlot".
+                                                            /// The default slot is 7, but the caller is free to use an alternative slot.
+                                                            /// If 0 is specified, then the default of 7 will be used.
+    AGSCrossfireMode            crossfireMode;              ///< Desired Crossfire mode
+} AGSDX11ExtensionParams_520;
+
+typedef union AGSDX11ExtensionParams
+{
+    AGSDX11ExtensionParams_511   agsDX11ExtensionParams511;
+    AGSDX11ExtensionParams_520   agsDX11ExtensionParams520;
 } AGSDX11ExtensionParams;
 
 /// The struct to hold all the returned parameters from the device creation call
-typedef struct AGSDX11ReturnedParams
+typedef struct AGSDX11ReturnedParams_511
 {
     ID3D11Device*           pDevice;                ///< The newly created device
     D3D_FEATURE_LEVEL       FeatureLevel;           ///< The feature level supported by the newly created device
     ID3D11DeviceContext*    pImmediateContext;      ///< The newly created immediate device context
     IDXGISwapChain*         pSwapChain;             ///< The newly created swap chain. This is only created if a valid pSwapChainDesc is supplied in AGSDX11DeviceCreationParams. This is not supported on the WACK compliant version
     unsigned int            extensionsSupported;    ///< Bit mask that \ref agsDriverExtensionsDX11_CreateDevice will fill in to indicate which extensions are supported. See AGSDriverExtensionDX11
+} AGSDX11ReturnedParams_511;
+
+typedef struct AGSDX11ReturnedParams_520
+{
+    ID3D11Device*           pDevice;                ///< The newly created device
+    ID3D11DeviceContext*    pImmediateContext;      ///< The newly created immediate device context
+    IDXGISwapChain*         pSwapChain;             ///< The newly created swap chain. This is only created if a valid pSwapChainDesc is supplied in AGSDX11DeviceCreationParams. This is not supported on the WACK compliant version
+    D3D_FEATURE_LEVEL       FeatureLevel;           ///< The feature level supported by the newly created device
+    unsigned int            extensionsSupported;    ///< Bit mask that \ref agsDriverExtensionsDX11_CreateDevice will fill in to indicate which extensions are supported. See \ref AGSDriverExtensionDX11
+    unsigned int            crossfireGPUCount;      ///< The number of GPUs that are active for this app
+    void*                   breadcrumbBuffer;       ///< The CPU buffer returned if the initialization of the breadcrumb was successful.
+} AGSDX11ReturnedParams_520;
+
+typedef union AGSDX11ReturnedParams
+{
+    AGSDX11ReturnedParams_511   agsDX11ReturnedParams511;
+    AGSDX11ReturnedParams_520   agsDX11ReturnedParams520;
 } AGSDX11ReturnedParams;
 
 ///
 /// Function used to create a D3D11 device with additional AMD-specific initialization parameters.
 ///
 /// When using the HLSL shader extensions please note:
-/// * The shader compiler should not use the D3DCOMPILE_SKIP_OPTIMIZATION option, otherwise it will not work.
+/// * The shader compiler should not use the D3DCOMPILE_SKIP_OPTIMIZATION (/Od) option, otherwise it will not work.
+/// * The shader compiler needs D3DCOMPILE_ENABLE_STRICTNESS (/Ges) enabled.
 ///
 /// \param [in] context                             Pointer to a context. This is generated by \ref agsInit
 /// \param [in] creationParams                      Pointer to the struct to specify the existing DX11 device creation parameters.
 /// \param [in] extensionParams                     Optional pointer to the struct to specify DX11 additional device creation parameters.
 /// \param [out] returnedParams                     Pointer to struct to hold all the returned parameters from the call.
 ///
-AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_CreateDevice( AGSContext* context, AGSDX11DeviceCreationParams* creationParams, AGSDX11ExtensionParams* extensionParams, AGSDX11ReturnedParams* returnedParams );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_CreateDevice( AGSContext* context, const AGSDX11DeviceCreationParams* creationParams, const AGSDX11ExtensionParams* extensionParams, AGSDX11ReturnedParams* returnedParams );
+
+///
+/// Function to destroy the D3D11 device and its immediate context.
+/// This call will also cleanup any AMD-specific driver extensions for D3D11.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] device                              Pointer to the D3D11 device.
+/// \param [out] deviceReferences                   Optional pointer to an unsigned int that will be set to the value returned from device->Release().
+/// \param [in] immediateContext                    Pointer to the D3D11 immediate device context.
+/// \param [out] immediateContextReferences         Optional pointer to an unsigned int that will be set to the value returned from immediateContext->Release().
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_DestroyDevice_520( AGSContext* context, ID3D11Device* device, unsigned int* deviceReferences, ID3D11DeviceContext* immediateContext, unsigned int* immediateContextReferences );
+
 
 ///
 /// Function to destroy the D3D11 device.
@@ -591,7 +748,7 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_CreateDevice( AGSContext* cont
 /// \param [in] device                              Pointer to the D3D11 device.
 /// \param [out] references                         Optional pointer to an unsigned int that will be set to the value returned from device->Release().
 ///
-AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_DestroyDevice( AGSContext* context, ID3D11Device* device, unsigned int* references );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_DestroyDevice_511( AGSContext* context, ID3D11Device* device, unsigned int* references );
 
 /// @}
 
@@ -626,6 +783,211 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_DestroyDevice( AGSContext* con
 ///
 /// @}
 
+/// \defgroup breadcrumbs Breadcrumb API
+/// API for writing top-of-pipe and bottom-of-pipe markers to help track down GPU hangs.
+///
+/// The API is available if the \ref AGS_DX11_EXTENSION_BREADCRUMB_MARKERS is present in \ref AGSDX11ReturnedParams::extensionsSupported.
+///
+/// To use the API, a non zero value needs to be specificed in \ref AGSDX11ExtensionParams::numBreadcrumbMarkers.  This enables the API (if available) and allocates a system memory buffer
+/// which is returned to the user in \ref AGSDX11ReturnedParams::breadcrumbBuffer.
+///
+/// The user can now write markers before and after draw calls using \ref agsDriverExtensionsDX11_WriteBreadcrumb.
+///
+/// \section background Background
+///
+/// A top-of-pipe (TOP) command is scheduled for execution as soon as the command processor (CP) reaches the command.
+/// A bottom-of-pipe (BOP) command is scheduled for execution once the previous rendering commands (draw and dispatch) finish execution.
+/// TOP and BOP commands do not block CP. i.e. the CP schedules the command for execution then proceeds to the next command without waiting.
+/// To effectively use TOP and BOP commands, it is important to understand how they interact with rendering commands:
+///
+/// When the CP encounters a rendering command it queues it for execution and moves to the next command.  The queued rendering commands are issued in order.
+/// There can be multiple rendering commands running in parallel.  When a rendering command is issued we say it is at the top of the pipe.  When a rendering command
+/// finishes execution we say it has reached the bottom of the pipe.
+///
+/// A BOP command remains in a waiting queue and is executed once prior rendering commands finish.  The queue of BOP commands is limited to 64 entries in GCN generation 1, 2, 3, 4 and 5.
+/// If the 64 limit is reached the CP will stop queueing BOP commands and also rendering commands.  Developers should limit the number of BOP commands that write markers to avoid contention.
+/// In general, developers should limit both TOP and BOP commands to avoid stalling the CP.
+///
+/// \subsection eg1 Example 1:
+///
+/// \code{.cpp}
+/// // Start of a command buffer
+/// WriteMarker(TopOfPipe, 1)
+/// WriteMarker(BottomOfPipe, 2)
+/// WriteMarker(BottomOfPipe, 3)
+/// DrawX
+/// WriteMarker(BottomOfPipe, 4)
+/// WriteMarker(BottomOfPipe, 5)
+/// WriteMarker(TopOfPipe, 6)
+/// // End of command buffer
+/// \endcode
+///
+/// In the above example, the CP writes markers 1, 2 and 3 without waiting:
+/// Marker 1 is TOP so it's independent from other commands
+/// There's no wait for marker 2 and 3 because there are no draws preceding the BOP commands
+/// Marker 4 is only written once DrawX finishes execution
+/// Marker 5 doesn't wait for additional draws so it is written right after marker 4
+/// Marker 6 can be written as soon as the CP reaches the command. For instance, it is very possible that CP writes marker 6 while DrawX 
+/// is running and therefore marker 6 gets written before markers 4 and 5
+///
+/// \subsection eg2 Example 2:
+///
+/// \code{.cpp}
+/// WriteMarker(TopOfPipe, 1)
+/// DrawX
+/// WriteMarker(BottomOfPipe, 2)
+/// WriteMarker(TopOfPipe, 3)
+/// DrawY
+/// WriteMarker(BottomOfPipe, 4)
+/// \endcode
+///
+/// In this example marker 1 is written before the start of DrawX
+/// Marker 2 is written once DrawX finishes execution
+/// Similarly marker 3 is written before the start of DrawY
+/// Marker 4 is written once DrawY finishes execution
+/// In case of a GPU hang, if markers 1 and 3 are written but markers 2 and 4 are missing we can conclude that:
+/// The CP has reached both DrawX and DrawY commands since marker 1 and 3 are present
+/// The fact that marker 2 and 4 are missing means that either DrawX is hanging while DrawY is at the top of the pipe or both DrawX and DrawY
+/// started and both are simultaneously hanging
+///
+/// \subsection eg3 Example 3:
+///
+/// \code{.cpp}
+/// // Start of a command buffer
+/// WriteMarker(BottomOfPipe, 1)
+/// DrawX
+/// WriteMarker(BottomOfPipe, 2)
+/// DrawY
+/// WriteMarker(BottomOfPipe, 3)
+/// DrawZ
+/// WriteMarker(BottomOfPipe, 4)
+/// // End of command buffer
+/// \endcode
+///
+/// In this example marker 1 is written before the start of DrawX
+/// Marker 2 is written once DrawX finishes
+/// Marker 3 is written once DrawY finishes
+/// Marker 4 is written once DrawZ finishes 
+/// If the GPU hangs and only marker 1 is written we can conclude that the hang is happening in either DrawX, DrawY or DrawZ
+/// If the GPU hangs and only marker 1 and 2 are written we can conclude that the hang is happening in DrawY or DrawZ
+/// If the GPU hangs and only marker 4 is missing we can conclude that the hang is happening in DrawZ
+///
+/// \subsection eg4 Example 4:
+///
+/// \code{.cpp}
+/// Start of a command buffer
+/// WriteMarker(TopOfPipe, 1)
+/// DrawX
+/// WriteMarker(TopOfPipe, 2)
+/// DrawY
+/// WriteMarker(TopOfPipe, 3)
+/// DrawZ
+/// // End of command buffer
+/// \endcode
+///
+/// In this example, in case the GPU hangs and only marker 1 is written we can conclude that the hang is happening in DrawX
+/// In case the GPU hangs and only marker 1 and 2 are written we can conclude that the hang is happening in DrawX or DrawY
+/// In case the GPU hangs and all 3 markers are written we can conclude that the hang is happening in any of DrawX, DrawY or DrawZ
+///
+/// \subsection eg5 Example 5:
+///
+/// \code{.cpp}
+/// DrawX
+/// WriteMarker(TopOfPipe, 1)
+/// WriteMarker(BottomOfPipe, 2)
+/// DrawY
+/// WriteMarker(TopOfPipe, 3)
+/// WriteMarker(BottomOfPipe, 4)
+/// \endcode
+///
+/// Marker 1 is written right after DrawX is queued for execution.
+/// Marker 2 is only written once DrawX finishes execution.
+/// Marker 3 is written right after DrawY is queued for execution.
+/// Marker 4 is only written once DrawY finishes execution
+/// If marker 1 is written we would know that the CP has reached the command DrawX (DrawX at the top of the pipe).
+/// If marker 2 is written we can say that DrawX has finished execution (DrawX at the bottom of the pipe). 
+/// In case the GPU hangs and only marker 1 and 3 are written we can conclude that the hang is happening in DrawX or DrawY
+/// In case the GPU hangs and only marker 1 is written we can conclude that the hang is happening in DrawX
+/// In case the GPU hangs and only marker 4 is missing we can conclude that the hang is happening in DrawY
+///
+/// \section data Retrieving GPU Data
+///
+/// In the event of a GPU hang, the user can inspect the system memory buffer to determine which draw has caused the hang.
+/// For example:
+/// \code{.cpp}
+///     // Force the work to be flushed to prevent CPU ahead of GPU
+///     g_pImmediateContext->Flush();
+///     
+///     // Present the information rendered to the back buffer to the front buffer (the screen)
+///     HRESULT hr = g_pSwapChain->Present( 0, 0 );
+///     
+///     // Read the marker data buffer once detect device lost
+///     if ( hr != S_OK )
+///     {
+///         for (UINT i = 0; i < g_NumMarkerWritten; i++)
+///         {
+///             UINT64* pTempData;
+///             pTempData = static_cast<UINT64*>(pMarkerBuffer);
+/// 
+///             // Write the marker data to file
+///             ofs << i << "\r\n";
+///             ofs << std::hex << *(pTempData + i * 2) << "\r\n";
+///             ofs << std::hex << *(pTempData + (i * 2 + 1)) << "\r\n";
+/// 
+///             WCHAR s1[256];
+///             setlocale(LC_NUMERIC, "en_US.iso88591");
+/// 
+///             // Output the marker data to console
+///             swprintf(s1, 256, L" The Draw count is %d; The Top maker is % 016llX and the Bottom marker is % 016llX \r\n", i, *(pTempData + i * 2), *(pTempData + (i * 2 + 1)));
+/// 
+///             OutputDebugStringW(s1);
+///         }
+///     }
+/// \endcode
+///
+/// The console output would resemble something like:
+/// \code{.cpp}
+/// D3D11: Removing Device. 
+/// D3D11 ERROR: ID3D11Device::RemoveDevice: Device removal has been triggered for the following reason (DXGI_ERROR_DEVICE_HUNG: The Device took an unreasonable amount of time to execute its commands, or the hardware crashed/hung. As a result, the TDR (Timeout Detection and Recovery) mechanism has been triggered. The current Device Context was executing commands when the hang occurred. The application may want to respawn and fallback to less aggressive use of the display hardware). [ EXECUTION ERROR #378: DEVICE_REMOVAL_PROCESS_AT_FAULT]
+///  The Draw count is 0; The Top maker is 00000000DEADCAFE and the Bottom marker is 00000000DEADBEEF 
+///  The Draw count is 1; The Top maker is 00000000DEADCAFE and the Bottom marker is 00000000DEADBEEF 
+///  The Draw count is 2; The Top maker is 00000000DEADCAFE and the Bottom marker is 00000000DEADBEEF 
+///  The Draw count is 3; The Top maker is 00000000DEADCAFE and the Bottom marker is 00000000DEADBEEF 
+///  The Draw count is 4; The Top maker is 00000000DEADCAFE and the Bottom marker is 00000000DEADBEEF 
+///  The Draw count is 5; The Top maker is CDCDCDCDCDCDCDCD and the Bottom marker is CDCDCDCDCDCDCDCD 
+///  The Draw count is 6; The Top maker is CDCDCDCDCDCDCDCD and the Bottom marker is CDCDCDCDCDCDCDCD 
+///  The Draw count is 7; The Top maker is CDCDCDCDCDCDCDCD and the Bottom marker is CDCDCDCDCDCDCDCD 
+/// \endcode
+/// 
+/// @{
+
+/// The breadcrumb marker struct used by \ref agsDriverExtensionsDX11_WriteBreadcrumb
+typedef struct AGSBreadcrumbMarker
+{
+    unsigned long long  markerData; ///< The user data to write.
+    enum
+    {
+        TopOfPipe       = 0,    ///< Top-of-pipe marker
+        BottomOfPipe    = 1     ///< Bottom-of-pipe marker
+    }                   type;       ///< Whether this marker is top or bottom of pipe.
+    unsigned int        index;      ///< The index of the marker. This should be less than the value specified in \ref AGSDX11ExtensionParams::numBreadcrumbMarkers
+} AGSBreadcrumbMarker;
+
+///
+/// Function to write a breadcrumb marker.
+///
+/// This method inserts a write marker operation in the GPU command stream. In the case where the GPU is hanging the write
+/// command will never be reached and the marker will never get written to memory.
+///
+/// In order to use this function, \ref AGSDX11ExtensionParams::numBreadcrumbMarkers must be set to a non zero value.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] marker                              Pointer to a marker.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_WriteBreadcrumb( AGSContext* context, const AGSBreadcrumbMarker* marker );
+
+/// @}
+
 /// \defgroup dx11misc Misc Extensions
 /// API for depth bounds test, UAV overlap and prim topologies
 /// @{
@@ -634,34 +996,37 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_DestroyDevice( AGSContext* con
 /// Function used to set the primitive topology. If you are using any of the extended topology types, then this function should
 /// be called to set ALL topology types.
 ///
-/// The Quad List extension is a convenient way to submit quads without using an index buffer. Note that this still submits two triangles at the driver level.
+/// The Quad List extension is a convenient way to submit quads without using an index buffer. Note that this still submits two triangles at the driver level. 
 /// In order to use this function, AGS must already be initialized and agsDriverExtensionsDX11_Init must have been called successfully.
 ///
-/// The Screen Rect extension, which is only available on GCN hardware, allows the user to pass in three of the four corners of a rectangle.
-/// The hardware then uses the bounding box of the vertices to rasterize the rectangle primitive (i.e. as a rectangle rather than two triangles).
+/// The Screen Rect extension, which is only available on GCN hardware, allows the user to pass in three of the four corners of a rectangle. 
+/// The hardware then uses the bounding box of the vertices to rasterize the rectangle primitive (i.e. as a rectangle rather than two triangles). 
 /// \note Note that this will not return valid interpolated values, only valid SV_Position values.
 /// \note If either the Quad List or Screen Rect extension are used, then agsDriverExtensionsDX11_IASetPrimitiveTopology should be called in place of the native DirectX11 equivalent all the time.
 ///
 /// \param [in] context                             Pointer to a context.
-/// \param [in] topology                            The topology to set on the D3D11 device. This can be either an AGS-defined topology such as AGS_PRIMITIVE_TOPOLOGY_QUAD_LIST
+/// \param [in] topology                            The topology to set on the D3D11 device. This can be either an AGS-defined topology such as AGS_PRIMITIVE_TOPOLOGY_QUADLIST
 ///                                                 or a standard D3D-defined topology such as D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP.
 ///                                                 NB. the AGS-defined types will require casting to a D3D_PRIMITIVE_TOPOLOGY type.
 ///
 AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_IASetPrimitiveTopology( AGSContext* context, enum D3D_PRIMITIVE_TOPOLOGY topology );
 
 ///
-/// Function used indicate to the driver it can overlap the subsequent batch of back-to-back dispatches.
+/// Function used indicate to the driver that it doesn't need to sync the UAVs bound for the subsequent set of back-to-back dispatches.
 /// When calling back-to-back draw calls or dispatch calls that write to the same UAV, the AMD DX11 driver will automatically insert a barrier to ensure there are no write after write (WAW) hazards.
 /// If the app can guarantee there is no overlap between the writes between these calls, then this extension will remove those barriers allowing the work to run in parallel on the GPU.
 ///
 /// Usage would be as follows:
 /// \code{.cpp}
+///     m_device->Dispatch( ... );  // First call that writes to the UAV
+///
 ///     // Disable automatic WAW syncs
 ///     agsDriverExtensionsDX11_BeginUAVOverlap( m_agsContext );
 ///
-///     // Submit back-to-back dispatches that write to the same UAV
-///     m_device->Dispatch( ... );  // First half of UAV
-///     m_device->Dispatch( ... );  // Second half of UAV
+///     // Submit other dispatches that write to the same UAV concurrently
+///     m_device->Dispatch( ... );
+///     m_device->Dispatch( ... );
+///     m_device->Dispatch( ... );
 ///
 ///     // Reenable automatic WAW syncs
 ///     agsDriverExtensionsDX11_EndUAVOverlap( m_agsContext );
@@ -952,9 +1337,9 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_NotifyResourceEndWrites( AGSCo
 AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_NotifyResourceBeginAllAccess( AGSContext* context, ID3D11Resource* resource );
 
 ///
-///   This is used for AGS_AFR_TRANSFER_1STEP_P2P to notify when it is safe to initiate a transfer.
-///   This call in frame N-(NumGpus-1) allows a 1 step P2P in frame N to start.
-///   This should be called after agsDriverExtensionsDX11_NotifyResourceEndWrites.
+/// This is used for AGS_AFR_TRANSFER_1STEP_P2P to notify when it is safe to initiate a transfer.
+/// This call in frame N-(NumGpus-1) allows a 1 step P2P in frame N to start.
+/// This should be called after agsDriverExtensionsDX11_NotifyResourceEndWrites.
 ///
 /// \param [in] context                             Pointer to a context.
 /// \param [in] resource                            Pointer to the resource.
--- dlls/amd_ags_x64/amd_ags.h
+++ dlls/amd_ags_x64/amd_ags.h
@@ -104,7 +110,7 @@
 
 #define AMD_AGS_VERSION_MAJOR 5             ///< AGS major version
 #define AMD_AGS_VERSION_MINOR 2             ///< AGS minor version
-#define AMD_AGS_VERSION_PATCH 0             ///< AGS patch version
+#define AMD_AGS_VERSION_PATCH 1             ///< AGS patch version
 
 #ifdef __cplusplus
 extern "C" {
@@ -628,7 +634,7 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_SetMarker( AGSContext* context
 /// The different modes to control Crossfire behavior.
 typedef enum AGSCrossfireMode
 {
-    AGS_CROSSFIRE_MODE_DRIVER_AFR = 0,                      ///< Use the default driver-based AFR rendering
+    AGS_CROSSFIRE_MODE_DRIVER_AFR = 0,                      ///< Use the default driver-based AFR rendering. If this mode is specified, do NOT use the agsDriverExtensionsDX11_Create*() APIs to create resources
     AGS_CROSSFIRE_MODE_EXPLICIT_AFR,                        ///< Use the AGS Crossfire API functions to perform explicit AFR rendering without requiring a CF driver profile
     AGS_CROSSFIRE_MODE_DISABLE                              ///< Completely disable AFR rendering
 } AGSCrossfireMode;
@@ -745,7 +751,7 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_DestroyDevice_511( AGSContext*
 
 /// \defgroup dx11appreg App Registration
 /// @{
-/// This extension allows an apllication to voluntarily register itself with the driver, providing a more robust app detection solution and avoid the issue of the driver
+/// This extension allows an apllication to voluntarily register itself with the driver, providing a more robust app detection solution and avoid the issue of the driver 
 /// relying on exe names to match the app to a driver profile.
 /// This feature is supported in Radeon Software Version 17.9.2 onwards.
 /// Rules:
@@ -1157,7 +1163,7 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetMaxAsyncCompileThreadCount(
 
 ///
 /// This method can be used to determine the total number of asynchronous shader compile jobs that are either
-/// queued for waiting for compilation or being compiled by the driver?s asynchronous compilation threads.
+/// queued for waiting for compilation or being compiled by the driver?s asynchronous compilation threads.
 /// This method can be called at any during the lifetime of the driver.
 ///
 /// \param [in] context                             Pointer to a context.
--- dlls/amd_ags_x64/amd_ags.h
+++ dlls/amd_ags_x64/amd_ags.h
@@ -111,8 +119,8 @@
 #define AMD_AGS_H
 
 #define AMD_AGS_VERSION_MAJOR 5             ///< AGS major version
-#define AMD_AGS_VERSION_MINOR 2             ///< AGS minor version
-#define AMD_AGS_VERSION_PATCH 1             ///< AGS patch version
+#define AMD_AGS_VERSION_MINOR 3             ///< AGS minor version
+#define AMD_AGS_VERSION_PATCH 0             ///< AGS patch version
 
 #ifdef __cplusplus
 extern "C" {
@@ -158,6 +169,7 @@ typedef enum AGSReturnCode
     AGS_ERROR_LEGACY_DRIVER,        ///< Returned if a feature is not present in the installed driver
     AGS_EXTENSION_NOT_SUPPORTED,    ///< Returned if the driver does not support the requested driver extension
     AGS_ADL_FAILURE,                ///< Failure in ADL (the AMD Display Library)
+    AGS_DX_FAILURE                  ///< Failure from DirectX runtime
 } AGSReturnCode;
 
 /// The DirectX11 extension support bits
@@ -184,6 +196,9 @@ typedef enum AGSDriverExtensionDX11
     AGS_DX11_EXTENSION_MULTIVIEW                            = 1 << 18,   ///< Supported in Radeon Software Version 16.12.1 onwards.
     AGS_DX11_EXTENSION_APP_REGISTRATION                     = 1 << 19,   ///< Supported in Radeon Software Version 17.9.1 onwards.
     AGS_DX11_EXTENSION_BREADCRUMB_MARKERS                   = 1 << 20,   ///< Supported in Radeon Software Version 17.11.1 onwards.
+    AGS_DX11_EXTENSION_MDI_DEFERRED_CONTEXTS                = 1 << 21,   ///< Supported in Radeon Software Version XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX onwards.
+    AGS_DX11_EXTENSION_UAV_OVERLAP_DEFERRED_CONTEXTS        = 1 << 22,   ///< Supported in Radeon Software Version XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX onwards.
+    AGS_DX11_EXTENSION_DEPTH_BOUNDS_DEFERRED_CONTEXTS       = 1 << 23    ///< Supported in Radeon Software Version XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX onwards.
 } AGSDriverExtensionDX11;
 
 /// The DirectX12 extension support bits
@@ -428,6 +443,8 @@ typedef struct AGSDisplaySettings
         Mode_HDR10_PQ,                                      ///< HDR10 PQ encoding, requiring a 1010102 UNORM swapchain and PQ encoding in the output shader.
         Mode_HDR10_scRGB,                                   ///< HDR10 scRGB, requiring an FP16 swapchain. Values of 1.0 == 80 nits, 125.0 == 10000 nits.
         Mode_Freesync2_scRGB,                               ///< Freesync2 scRGB, requiring an FP16 swapchain. 1.0 == 80 nits. Tonemap your scene to the range of 0.0 to AGSDisplayInfo::maxLuminance.
+        // Mode_Freesync2_Gamma22 ADDED IN 5.3.0
+        Mode_Freesync2_Gamma22,                             ///< Freesync2 Gamma 2.2, requiring a 1010102 UNORM swapchain.  The output needs to be encoded to gamma 2.2.
         Mode_DolbyVision                                    ///< Dolby Vision, requiring an 8888 UNORM swapchain
     }                       mode;                           ///< The display mode to set the display into
 
@@ -523,7 +558,7 @@ AMD_AGS_API AGSReturnCode agsSetDisplayMode( AGSContext* context, int deviceInde
 /// DirectX12 driver extensions
 /// @{
 
-/// \defgroup dx12init Device creation and cleanup
+/// \defgroup dx12init Device and device object creation and cleanup
 /// It is now mandatory to call \ref agsDriverExtensionsDX12_CreateDevice when creating a device if the user wants to access any future DX12 AMD extensions.
 /// The corresponding \ref agsDriverExtensionsDX12_DestroyDevice call must be called to release the device and free up the internal resources allocated by the create call.
 /// @{
@@ -536,9 +571,6 @@ typedef struct AGSDX12DeviceCreationParams
     D3D_FEATURE_LEVEL           FeatureLevel;               ///< The minimum feature level to create the device with.
 } AGSDX12DeviceCreationParams;
 
-#define AGS_MAKE_VERSION( major, minor, patch ) ( ( major << 22 ) | ( minor << 12 ) | patch ) ///< Macro to create the app and engine versions for the fields in \ref AGSDX12ExtensionParams and \ref AGSDX11ExtensionParams
-#define AGS_UNSPECIFIED_VERSION 0xFFFFAD00                                                    ///< Use this to specify no version
-
 /// The struct to specify DX12 additional device creation parameters
 typedef struct AGSDX12ExtensionParams
 {
@@ -657,7 +689,7 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_SetMarker( AGSContext* context
 /// The different modes to control Crossfire behavior.
 typedef enum AGSCrossfireMode
 {
-    AGS_CROSSFIRE_MODE_DRIVER_AFR = 0,                      ///< Use the default driver-based AFR rendering. If this mode is specified, do NOT use the agsDriverExtensionsDX11_Create*() APIs to create resources
+    AGS_CROSSFIRE_MODE_DRIVER_AFR = 0,                      ///< Use the default driver-based AFR rendering.  If this mode is specified, do NOT use the agsDriverExtensionsDX11_Create*() APIs to create resources
     AGS_CROSSFIRE_MODE_EXPLICIT_AFR,                        ///< Use the AGS Crossfire API functions to perform explicit AFR rendering without requiring a CF driver profile
     AGS_CROSSFIRE_MODE_DISABLE                              ///< Completely disable AFR rendering
 } AGSCrossfireMode;
@@ -1007,8 +1039,8 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_WriteBreadcrumb( AGSContext* c
 
 /// @}
 
-/// \defgroup dx11misc Misc Extensions
-/// API for depth bounds test, UAV overlap and prim topologies
+/// \defgroup dx11Topology Extended Topology
+/// API for primitive topologies
 /// @{
 
 ///
@@ -1058,25 +1096,39 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_IASetPrimitiveTopology( AGSCon
 /// \endcode
 ///
 /// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
+///                                                 with the AGS_DX11_EXTENSION_DEFERRED_CONTEXTS bit.
 ///
-AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_BeginUAVOverlap( AGSContext* context );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_BeginUAVOverlap_520( AGSContext* context );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_BeginUAVOverlap( AGSContext* context, ID3D11DeviceContext* dxContext );
 
 ///
 /// Function used indicate to the driver it can no longer overlap the batch of back-to-back dispatches that has been submitted.
 ///
 /// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
+///                                                 with the AGS_DX11_EXTENSION_DEFERRED_CONTEXTS bit.
 ///
-AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_EndUAVOverlap( AGSContext* context );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_EndUAVOverlap_520( AGSContext* context );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_EndUAVOverlap( AGSContext* context, ID3D11DeviceContext* dxContext );
+
+/// @}
+
+/// \defgroup dx11DepthBoundsTest Depth Bounds Test
+/// API for enabling depth bounds testing
+/// @{
 
 ///
 /// Function used to set the depth bounds test extension
 ///
-/// \param [in] context                             Pointer to a context.
+/// \param [in] context                             Pointer to a context
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
 /// \param [in] enabled                             Whether to enable or disable the depth bounds testing. If disabled, the next two args are ignored.
 /// \param [in] minDepth                            The near depth range to clip against.
 /// \param [in] maxDepth                            The far depth range to clip against.
 ///
-AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetDepthBounds( AGSContext* context, bool enabled, float minDepth, float maxDepth );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetDepthBounds_520( AGSContext* context, bool enabled, float minDepth, float maxDepth );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetDepthBounds( AGSContext* context, ID3D11DeviceContext* dxContext, bool enabled, float minDepth, float maxDepth );
 
 /// @}
 
@@ -1089,12 +1141,12 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetDepthBounds( AGSContext* co
 /// \code{.cpp}
 ///     // Submit n batches of DrawIndirect calls
 ///     for ( int i = 0; i < n; i++ )
-///         DrawIndexedInstancedIndirect( buffer, i * sizeof( cmd ) );
+///         deviceContext->DrawIndexedInstancedIndirect( buffer, i * sizeof( cmd ) );
 /// \endcode
 /// To be replaced by the following call:
 /// \code{.cpp}
 ///     // Submit all n batches in one call
-///     agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirect( m_agsContext, n, buffer, 0, sizeof( cmd ) );
+///     agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirect( m_agsContext, deviceContext, n, buffer, 0, sizeof( cmd ) );
 /// \endcode
 ///
 /// The buffer used for the indirect args must be of the following formats:
@@ -1127,47 +1179,55 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetDepthBounds( AGSContext* co
 /// Function used to submit a batch of draws via MultiDrawIndirect
 ///
 /// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
 /// \param [in] drawCount                           The number of draws.
 /// \param [in] pBufferForArgs                      The args buffer.
 /// \param [in] alignedByteOffsetForArgs            The offset into the args buffer.
 /// \param [in] byteStrideForArgs                   The per element stride of the args buffer.
 ///
-AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawInstancedIndirect( AGSContext* context, unsigned int drawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawInstancedIndirect_520( AGSContext* context, unsigned int drawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawInstancedIndirect( AGSContext* context, ID3D11DeviceContext* dxContext, unsigned int drawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
 
 ///
 /// Function used to submit a batch of draws via MultiDrawIndirect
 ///
 /// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
 /// \param [in] drawCount                           The number of draws.
 /// \param [in] pBufferForArgs                      The args buffer.
 /// \param [in] alignedByteOffsetForArgs            The offset into the args buffer.
 /// \param [in] byteStrideForArgs                   The per element stride of the args buffer.
 ///
-AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirect( AGSContext* context, unsigned int drawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirect_520( AGSContext* context, unsigned int drawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirect( AGSContext* context, ID3D11DeviceContext* dxContext, unsigned int drawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
 
 ///
 /// Function used to submit a batch of draws via MultiDrawIndirect
 ///
 /// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
 /// \param [in] pBufferForDrawCount                 The draw count buffer.
 /// \param [in] alignedByteOffsetForDrawCount       The offset into the draw count buffer.
 /// \param [in] pBufferForArgs                      The args buffer.
 /// \param [in] alignedByteOffsetForArgs            The offset into the args buffer.
 /// \param [in] byteStrideForArgs                   The per element stride of the args buffer.
 ///
-AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawInstancedIndirectCountIndirect( AGSContext* context, ID3D11Buffer* pBufferForDrawCount, unsigned int alignedByteOffsetForDrawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawInstancedIndirectCountIndirect_520( AGSContext* context, ID3D11Buffer* pBufferForDrawCount, unsigned int alignedByteOffsetForDrawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawInstancedIndirectCountIndirect( AGSContext* context, ID3D11DeviceContext* dxContext, ID3D11Buffer* pBufferForDrawCount, unsigned int alignedByteOffsetForDrawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
 
 ///
 /// Function used to submit a batch of draws via MultiDrawIndirect
 ///
 /// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
 /// \param [in] pBufferForDrawCount                 The draw count buffer.
 /// \param [in] alignedByteOffsetForDrawCount       The offset into the draw count buffer.
 /// \param [in] pBufferForArgs                      The args buffer.
 /// \param [in] alignedByteOffsetForArgs            The offset into the args buffer.
 /// \param [in] byteStrideForArgs                   The per element stride of the args buffer.
 ///
-AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirectCountIndirect( AGSContext* context, ID3D11Buffer* pBufferForDrawCount, unsigned int alignedByteOffsetForDrawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirectCountIndirect_520( AGSContext* context, ID3D11Buffer* pBufferForDrawCount, unsigned int alignedByteOffsetForDrawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirectCountIndirect( AGSContext* context, ID3D11DeviceContext* dxContext, ID3D11Buffer* pBufferForDrawCount, unsigned int alignedByteOffsetForDrawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
 
 /// @}
 
--- dlls/amd_ags_x64/amd_ags.h
+++ dlls/amd_ags_x64/amd_ags.h
@@ -119,7 +127,7 @@
 #define AMD_AGS_H
 
 #define AMD_AGS_VERSION_MAJOR 5             ///< AGS major version
-#define AMD_AGS_VERSION_MINOR 3             ///< AGS minor version
+#define AMD_AGS_VERSION_MINOR 4             ///< AGS minor version
 #define AMD_AGS_VERSION_PATCH 0             ///< AGS patch version
 
 #ifdef __cplusplus
@@ -193,9 +201,11 @@ typedef enum AGSDriverExtensionDX11
     AGS_DX11_EXTENSION_MULTIVIEW                            = 1 << 18,   ///< Supported in Radeon Software Version 16.12.1 onwards.
     AGS_DX11_EXTENSION_APP_REGISTRATION                     = 1 << 19,   ///< Supported in Radeon Software Version 17.9.1 onwards.
     AGS_DX11_EXTENSION_BREADCRUMB_MARKERS                   = 1 << 20,   ///< Supported in Radeon Software Version 17.11.1 onwards.
-    AGS_DX11_EXTENSION_MDI_DEFERRED_CONTEXTS                = 1 << 21,   ///< Supported in Radeon Software Version XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX onwards.
-    AGS_DX11_EXTENSION_UAV_OVERLAP_DEFERRED_CONTEXTS        = 1 << 22,   ///< Supported in Radeon Software Version XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX onwards.
-    AGS_DX11_EXTENSION_DEPTH_BOUNDS_DEFERRED_CONTEXTS       = 1 << 23    ///< Supported in Radeon Software Version XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX onwards.
+    AGS_DX11_EXTENSION_MDI_DEFERRED_CONTEXTS                = 1 << 21,   ///< Supported in Radeon Software Version 18.8.1 onwards.
+    AGS_DX11_EXTENSION_UAV_OVERLAP_DEFERRED_CONTEXTS        = 1 << 22,   ///< Supported in Radeon Software Version 18.8.1 onwards.
+    AGS_DX11_EXTENSION_DEPTH_BOUNDS_DEFERRED_CONTEXTS       = 1 << 23,   ///< Supported in Radeon Software Version 18.8.1 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_DRAW_INDEX                 = 1 << 24,   ///< Supported in Radeon Software Version 19.12.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_ATOMIC_U64                 = 1 << 25    ///< Supported in Radeon Software Version 19.12.2 onwards.
 } AGSDriverExtensionDX11;
 
 /// The DirectX12 extension support bits
@@ -212,7 +222,10 @@ typedef enum AGSDriverExtensionDX12
     AGS_DX12_EXTENSION_INTRINSIC_WAVE_REDUCE                = 1 << 8,   ///< Supported in Radeon Software Version 17.9.1 onwards.
     AGS_DX12_EXTENSION_INTRINSIC_WAVE_SCAN                  = 1 << 9,   ///< Supported in Radeon Software Version 17.9.1 onwards.
     AGS_DX12_EXTENSION_USER_MARKERS                         = 1 << 10,  ///< Supported in Radeon Software Version 17.9.1 onwards.
-    AGS_DX12_EXTENSION_APP_REGISTRATION                     = 1 << 11   ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX12_EXTENSION_APP_REGISTRATION                     = 1 << 11,  ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_UAV_BIND_SLOT              = 1 << 12,  ///< Supported in Radeon Software Version 19.5.1 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_DRAW_INDEX                 = 1 << 13,  ///< Supported in Radeon Software Version 19.12.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_ATOMIC_U64                 = 1 << 14   ///< Supported in Radeon Software Version 19.12.2 onwards.
 } AGSDriverExtensionDX12;
 
 /// The space id for DirectX12 intrinsic support
@@ -395,10 +421,48 @@ typedef struct AGSDeviceInfo_520
     int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
 } AGSDeviceInfo_520;
 
+/// The device info struct used to describe a physical GPU enumerated by AGS
+typedef struct AGSDeviceInfo_540
+{
+    const char*                     adapterString;                  ///< The adapter name string
+    AsicFamily                      asicFamily;                     ///< Set to Unknown if not AMD hardware
+    int                             isAPU;                          ///< Whether or not this is an APU
+    int                             vendorId;                       ///< The vendor id
+    int                             deviceId;                       ///< The device id
+    int                             revisionId;                     ///< The revision id
+
+    int                             numCUs;                         ///< Number of compute units.
+    int                             numWGPs;                        ///< Number of RDNA Work Group Processors.  Only valid if ASIC is RDNA onwards.
+
+    int                             numROPs;                        ///< Number of ROPs
+    int                             coreClock;                      ///< Core clock speed at 100% power in MHz
+    int                             memoryClock;                    ///< Memory clock speed at 100% power in MHz
+    int                             memoryBandwidth;                ///< Memory bandwidth in MB/s
+    float                           teraFlops;                      ///< Teraflops of GPU. Zero if not GCN onwards. Calculated from iCoreClock * iNumCUs * 64 Pixels/clk * 2 instructions/MAD
+
+    int                             isPrimaryDevice;                ///< Whether or not this is the primary adapter in the system. Not set on the WACK version.
+    unsigned long long              localMemoryInBytes;             ///< The size of local memory in bytes.
+    unsigned long long              sharedMemoryInBytes;            ///< The size of system memory available to the GPU in bytes.  It is important to factor this into your VRAM budget for APUs
+                                                                    ///< as the reported local memory will only be a small fraction of the total memory available to the GPU.
+
+    int                             numDisplays;                    ///< The number of active displays found to be attached to this adapter.
+    AGSDisplayInfo*                 displays;                       ///< List of displays allocated by AGS to be numDisplays in length.
+
+    int                             eyefinityEnabled;               ///< Indicates if Eyefinity is active
+    int                             eyefinityGridWidth;             ///< Contains width of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityGridHeight;            ///< Contains height of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityResolutionX;           ///< Contains width in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityResolutionY;           ///< Contains height in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityBezelCompensated;      ///< Indicates if bezel compensation is used for the current SLS display area. 1 if enabled, and 0 if disabled.
+
+    int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
+} AGSDeviceInfo_540;
+
 typedef union AGSDeviceInfo
 {
     AGSDeviceInfo_511 agsDeviceInfo511;
     AGSDeviceInfo_520 agsDeviceInfo520;
+    AGSDeviceInfo_540 agsDeviceInfo540;
 } AGSDeviceInfo;
 
 /// \defgroup general General API functions
@@ -570,6 +634,8 @@ typedef struct AGSDX12ExtensionParams
     const WCHAR*    pEngineName;            ///< Engine name
     unsigned int    appVersion;             ///< Application version
     unsigned int    engineVersion;          ///< Engine version
+    // ADDED IN 5.4.0
+    unsigned int    uavSlot;                ///< The UAV slot reserved for intrinsic support.  Refer to the \ref agsDriverExtensionsDX12_CreateDevice documentation for more details.
 } AGSDX12ExtensionParams;
 
 /// The struct to hold all the returned parameters from the device creation call
@@ -649,7 +727,7 @@ AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_DeInit( AGSContext* context );
 
 ///
 /// Function used to push an AMD user marker onto the command list.
-/// This is only has an effect if AGS_DX12_EXTENSION_USER_MARKERS is present in the extensionsSupported bitfield of \ref agsDriverExtensionsDX12_CreateDevice
+/// This is only has an effect if \ref AGS_DX12_EXTENSION_USER_MARKERS is present in the extensionsSupported bitfield of \ref agsDriverExtensionsDX12_CreateDevice
 /// Supported in Radeon Software Version 17.9.1 onwards.
 ///
 /// \param [in] context                             Pointer to a context.
--- dlls/amd_ags_x64/amd_ags.h
+++ dlls/amd_ags_x64/amd_ags.h
@@ -1,5 +1,5 @@
 //
-// Copyright (c) 2018 Advanced Micro Devices, Inc. All rights reserved.
+// Copyright (c) 2020 Advanced Micro Devices, Inc. All rights reserved.
 //
 // Permission is hereby granted, free of charge, to any person obtaining a copy
 // of this software and associated documentation files (the "Software"), to deal
@@ -34,11 +34,21 @@
 /// \endinternal
 ///
 /// ---------------------------------------
+/// What's new in AGS 5.4.1 since version 5.4.0
+/// ---------------------------------------
+/// AGS 5.4.1 includes the following updates:
+/// * AsicFamily_Count to help with code maintenance.
+/// * Visual Studio 2019 support.
+/// * x86 support
+/// * BaseInstance and BaseVertex intrinsics along with corresponding caps bits.
+/// * GetWaveSize intrinsic along with corresponding caps bits.
+///
+/// ---------------------------------------
 /// What's new in AGS 5.4 since version 5.3
 /// ---------------------------------------
 /// AGS 5.4 includes the following updates:
 /// * A more detailed description of the GPU architecture, now including RDNA GPUs.
-/// * Navi 10, Navi 14 and Radeon 7 core and memory speeds returned.
+/// * Radeon 7 core and memory speeds returned.
 /// * Draw index and Atomic U64 intrinsics for both DX11 and DX12.
 ///
 /// ---------------------------------------
@@ -47,7 +57,7 @@
 /// AGS 5.3 includes the following updates:
 /// * DX11 deferred context support for Multi Draw Indirect and UAV Overlap extensions.
 /// * A Radeon Software Version helper to determine whether the installed driver meets your game's minimum driver version requirements.
-/// * Freesync2 Gamma 2.2 mode which uses a 1010102 swapchain and can be considered as an alternative to using the 64 bit swapchain required for Freesync2 scRGB.
+/// * Freesync HDR Gamma 2.2 mode which uses a 1010102 swapchain and can be considered as an alternative to using the 64 bit swapchain required for Freesync HDR scRGB.
 ///
 /// What's new in AGS 5.2.1 since version 5.2.0
 /// ---------------------------------------
@@ -120,16 +130,19 @@
 
 #define AMD_AGS_VERSION_MAJOR 5             ///< AGS major version
 #define AMD_AGS_VERSION_MINOR 4             ///< AGS minor version
-#define AMD_AGS_VERSION_PATCH 0             ///< AGS patch version
+#define AMD_AGS_VERSION_PATCH 1             ///< AGS patch version
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+/// \defgroup Defines AGS defines
+/// @{
 #define AMD_AGS_API WINAPI
 
 #define AGS_MAKE_VERSION( major, minor, patch ) ( ( major << 22 ) | ( minor << 12 ) | patch ) ///< Macro to create the app and engine versions for the fields in \ref AGSDX12ExtensionParams and \ref AGSDX11ExtensionParams and the Radeon Software Version
 #define AGS_UNSPECIFIED_VERSION 0xFFFFAD00                                                    ///< Use this to specify no version
+/// @}
 
 // Forward declaration of D3D11 types
 struct IDXGIAdapter;
@@ -154,6 +167,8 @@ struct D3D11_SUBRESOURCE_DATA;
 struct ID3D12Device;
 struct ID3D12GraphicsCommandList;
 
+/// \defgroup enums General enumerations
+/// @{
 
 /// The return codes
 typedef enum AGSReturnCode
@@ -162,8 +177,10 @@ typedef enum AGSReturnCode
     AGS_FAILURE,                    ///< Failed to complete call for some unspecified reason
     AGS_INVALID_ARGS,               ///< Invalid arguments into the function
     AGS_OUT_OF_MEMORY,              ///< Out of memory when allocating space internally
-    AGS_ERROR_MISSING_DLL,          ///< Returned when a driver dll fails to load - most likely due to not being present in legacy driver installation
-    AGS_ERROR_LEGACY_DRIVER,        ///< Returned if a feature is not present in the installed driver
+    AGS_MISSING_D3D_DLL,            ///< Returned when a D3D dll fails to load
+    AGS_LEGACY_DRIVER,              ///< Returned if a feature is not present in the installed driver
+    // AGS_NO_AMD_DRIVER_INSTALLED ADDED IN 5.4.1
+    AGS_NO_AMD_DRIVER_INSTALLED,    ///< Returned if the AMD GPU driver does not appear to be installed
     AGS_EXTENSION_NOT_SUPPORTED,    ///< Returned if the driver does not support the requested driver extension
     AGS_ADL_FAILURE,                ///< Failure in ADL (the AMD Display Library)
     AGS_DX_FAILURE                  ///< Failure from DirectX runtime
@@ -197,7 +214,10 @@ typedef enum AGSDriverExtensionDX11
     AGS_DX11_EXTENSION_UAV_OVERLAP_DEFERRED_CONTEXTS        = 1 << 22,   ///< Supported in Radeon Software Version 18.8.1 onwards.
     AGS_DX11_EXTENSION_DEPTH_BOUNDS_DEFERRED_CONTEXTS       = 1 << 23,   ///< Supported in Radeon Software Version 18.8.1 onwards.
     AGS_DX11_EXTENSION_INTRINSIC_DRAW_INDEX                 = 1 << 24,   ///< Supported in Radeon Software Version 19.12.2 onwards.
-    AGS_DX11_EXTENSION_INTRINSIC_ATOMIC_U64                 = 1 << 25    ///< Supported in Radeon Software Version 19.12.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_ATOMIC_U64                 = 1 << 25,   ///< Supported in Radeon Software Version 19.12.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_GET_WAVE_SIZE              = 1 << 26,   ///< Supported in Radeon Software Version 20.2.1 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_BASE_VERTEX                = 1 << 27,   ///< Supported in Radeon Software Version 20.2.1 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_BASE_INSTANCE              = 1 << 28    ///< Supported in Radeon Software Version 20.2.1 onwards.
 } AGSDriverExtensionDX11;
 
 /// The DirectX12 extension support bits
@@ -217,7 +237,10 @@ typedef enum AGSDriverExtensionDX12
     AGS_DX12_EXTENSION_APP_REGISTRATION                     = 1 << 11,  ///< Supported in Radeon Software Version 17.9.1 onwards.
     AGS_DX12_EXTENSION_INTRINSIC_UAV_BIND_SLOT              = 1 << 12,  ///< Supported in Radeon Software Version 19.5.1 onwards.
     AGS_DX12_EXTENSION_INTRINSIC_DRAW_INDEX                 = 1 << 13,  ///< Supported in Radeon Software Version 19.12.2 onwards.
-    AGS_DX12_EXTENSION_INTRINSIC_ATOMIC_U64                 = 1 << 14   ///< Supported in Radeon Software Version 19.12.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_ATOMIC_U64                 = 1 << 14,  ///< Supported in Radeon Software Version 19.12.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_BASE_VERTEX                = 1 << 15,  ///< Supported in Radeon Software Version 20.2.1 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_BASE_INSTANCE              = 1 << 16,  ///< Supported in Radeon Software Version 20.2.1 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_GET_WAVE_SIZE              = 1 << 17   ///< Supported in Radeon Software Version 20.5.1 onwards.
 } AGSDriverExtensionDX12;
 
 /// The space id for DirectX12 intrinsic support
@@ -238,7 +261,7 @@ typedef enum AGSDisplayFlags
     AGS_DISPLAYFLAG_HDR10                                   = 1 << 1,   ///< HDR10 is supported on this display
     AGS_DISPLAYFLAG_DOLBYVISION                             = 1 << 2,   ///< Dolby Vision is supported on this display
     AGS_DISPLAYFLAG_FREESYNC                                = 1 << 3,   ///< Freesync is supported on this display
-    AGS_DISPLAYFLAG_FREESYNC_2                              = 1 << 4,   ///< Freesync 2 is supported on this display
+    AGS_DISPLAYFLAG_FREESYNC_HDR                            = 1 << 4,   ///< Freesync HDR is supported on this display
     AGS_DISPLAYFLAG_EYEFINITY_IN_GROUP                      = 1 << 5,   ///< The display is part of the Eyefinity group
     AGS_DISPLAYFLAG_EYEFINITY_PREFERRED_DISPLAY             = 1 << 6,   ///< The display is the preferred display in the Eyefinity group for displaying the UI
     AGS_DISPLAYFLAG_EYEFINITY_IN_PORTRAIT_MODE              = 1 << 7,   ///< The display is in the Eyefinity group but in portrait mode
@@ -250,6 +273,7 @@ typedef enum AGSDisplaySettingsFlags
     AGS_DISPLAYSETTINGSFLAG_DISABLE_LOCAL_DIMMING           = 1 << 0,   ///< Disables local dimming if possible
 } AGSDisplaySettingsFlags;
 
+/// @}
 
 typedef struct AGSContext AGSContext;  ///< All function calls in AGS require a pointer to a context. This is generated via \ref agsInit
 
@@ -280,7 +304,7 @@ typedef struct AGSDisplayInfo
     char                    name[ 256 ];                    ///< The name of the display
     char                    displayDeviceName[ 32 ];        ///< The display device name, i.e. DISPLAY_DEVICE::DeviceName
 
-    unsigned int            displayFlags;                   ///< Bitfield of ::AGSDisplayFlags
+    unsigned int            displayFlags;                   ///< Bitfield of \ref AGSDisplayFlags
 
     int                     maxResolutionX;                 ///< The maximum supported resolution of the unrotated display
     int                     maxResolutionY;                 ///< The maximum supported resolution of the unrotated display
@@ -335,7 +359,9 @@ typedef enum AsicFamily
     AsicFamily_GCN3,                                            ///< AMD GCN 3 architecture: Tonga & Fiji.
     AsicFamily_GCN4,                                            ///< AMD GCN 4 architecture: Polaris.
     AsicFamily_Vega,                                            ///< AMD Vega architecture, including Raven Ridge (ie AMD Ryzen CPU + AMD Vega GPU).
-    AsicFamily_RDNA                                             ///< AMD RDNA architecture
+    AsicFamily_RDNA,                                            ///< AMD RDNA architecture
+
+    AsicFamily_Count                                            ///< Number of enumerated ASIC families
 } AsicFamily;
 
 /// The device info struct used to describe a physical GPU enumerated by AGS
@@ -437,11 +463,47 @@ typedef struct AGSDeviceInfo_540
     int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
 } AGSDeviceInfo_540;
 
+/// The device info struct used to describe a physical GPU enumerated by AGS
+typedef struct AGSDeviceInfo_541
+{
+    const char*                     adapterString;                  ///< The adapter name string
+    AsicFamily                      asicFamily;                     ///< Set to Unknown if not AMD hardware
+    int                             isAPU;                          ///< Whether or not this is an APU
+    int                             vendorId;                       ///< The vendor id
+    int                             deviceId;                       ///< The device id
+    int                             revisionId;                     ///< The revision id
+
+    int                             numCUs;                         ///< Number of compute units.
+    int                             numWGPs;                        ///< Number of RDNA Work Group Processors.  Only valid if ASIC is RDNA onwards.
+
+    int                             numROPs;                        ///< Number of ROPs
+    int                             coreClock;                      ///< Core clock speed at 100% power in MHz
+    int                             memoryClock;                    ///< Memory clock speed at 100% power in MHz
+    int                             memoryBandwidth;                ///< Memory bandwidth in MB/s
+    float                           teraFlops;                      ///< Teraflops of GPU. Zero if not GCN onwards. Calculated from iCoreClock * iNumCUs * 64 Pixels/clk * 2 instructions/MAD
+
+    int                             isPrimaryDevice;                ///< Whether or not this is the primary adapter in the system. Not set on the WACK version.
+    long long                       localMemoryInBytes;             ///< The size of local memory in bytes. 0 for non AMD hardware.
+
+    int                             numDisplays;                    ///< The number of active displays found to be attached to this adapter.
+    AGSDisplayInfo*                 displays;                       ///< List of displays allocated by AGS to be numDisplays in length.
+
+    int                             eyefinityEnabled;               ///< Indicates if Eyefinity is active
+    int                             eyefinityGridWidth;             ///< Contains width of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityGridHeight;            ///< Contains height of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityResolutionX;           ///< Contains width in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityResolutionY;           ///< Contains height in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityBezelCompensated;      ///< Indicates if bezel compensation is used for the current SLS display area. 1 if enabled, and 0 if disabled.
+
+    int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
+} AGSDeviceInfo_541;
+
 typedef union AGSDeviceInfo
 {
     AGSDeviceInfo_511 agsDeviceInfo511;
     AGSDeviceInfo_520 agsDeviceInfo520;
     AGSDeviceInfo_540 agsDeviceInfo540;
+    AGSDeviceInfo_541 agsDeviceInfo541;
 } AGSDeviceInfo;
 
 /// \defgroup general General API functions
@@ -495,10 +557,12 @@ typedef struct AGSDisplaySettings
         Mode_SDR,                                           ///< SDR mode
         Mode_HDR10_PQ,                                      ///< HDR10 PQ encoding, requiring a 1010102 UNORM swapchain and PQ encoding in the output shader.
         Mode_HDR10_scRGB,                                   ///< HDR10 scRGB, requiring an FP16 swapchain. Values of 1.0 == 80 nits, 125.0 == 10000 nits.
-        Mode_Freesync2_scRGB,                               ///< Freesync2 scRGB, requiring an FP16 swapchain. 1.0 == 80 nits. Tonemap your scene to the range of 0.0 to AGSDisplayInfo::maxLuminance.
-        // Mode_Freesync2_Gamma22 ADDED IN 5.3.0
-        Mode_Freesync2_Gamma22,                             ///< Freesync2 Gamma 2.2, requiring a 1010102 UNORM swapchain.  The output needs to be encoded to gamma 2.2.
-        Mode_DolbyVision                                    ///< Dolby Vision, requiring an 8888 UNORM swapchain
+        Mode_FreesyncHDR_scRGB,                             ///< Freesync HDR scRGB, requiring an FP16 swapchain. A value of 1.0 == 80 nits.
+        // Mode_FreesyncHDR_Gamma22 ADDED IN 5.3.0
+        Mode_FreesyncHDR_Gamma22,                           ///< Freesync HDR Gamma 2.2, requiring a 1010102 UNORM swapchain.  The output needs to be encoded to gamma 2.2.
+        Mode_DolbyVision,                                   ///< Dolby Vision, requiring an 8888 UNORM swapchain
+
+        Mode_Count                                          ///< Number of enumerated display modes
     }                       mode;                           ///< The display mode to set the display into
 
     double                  chromaticityRedX;               ///< Red display primary X coord
@@ -545,7 +609,9 @@ AMD_AGS_API AGSDriverVersionResult agsCheckDriverVersion( const char* radeonSoft
 /// Function used to initialize the AGS library.
 /// Must be called prior to any of the subsequent AGS API calls.
 /// Must be called prior to ID3D11Device or ID3D12Device creation.
-/// \note This function will fail with \ref AGS_ERROR_LEGACY_DRIVER in Catalyst versions before 12.20.
+/// \note The caller of this function should handle the possibility of the call failing in the cases below. One option is to do a vendor id check and only call \ref agsInit if there is an AMD GPU present.
+/// \note This function will fail with \ref AGS_NO_AMD_DRIVER_INSTALLED if there is no AMD driver found on the system.
+/// \note This function will fail with \ref AGS_LEGACY_DRIVER in Catalyst versions before 12.20.
 /// \note It is good practice to check the AGS version returned from AGSGPUInfo against the version defined in the header in case a mismatch between the dll and header has occurred.
 ///
 /// \param [in, out] context                        Address of a pointer to a context. This function allocates a context on the heap which is then required for all subsequent API calls.
@@ -577,7 +643,8 @@ AMD_AGS_API AGSReturnCode agsGetCrossfireGPUCount( AGSContext* context, int* num
 /// \note Call this function after each mode change (switch to fullscreen, any change in swapchain etc).
 /// \note HDR10 PQ mode requires a 1010102 swapchain.
 /// \note HDR10 scRGB mode requires an FP16 swapchain.
-/// \note Freesync2 scRGB mode requires an FP16 swapchain.
+/// \note Freesync HDR scRGB mode requires an FP16 swapchain.
+/// \note Freesync HDR Gamma 2.2 mode requires a 1010102 swapchain.
 /// \note Dolby Vision requires a 8888 UNORM swapchain.
 ///
 /// \param [in] context                             Pointer to a context. This is generated by \ref agsInit
