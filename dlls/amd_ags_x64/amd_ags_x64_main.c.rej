--- dlls/amd_ags_x64/amd_ags_x64_main.c
+++ dlls/amd_ags_x64/amd_ags_x64_main.c
@@ -1,5 +1,3 @@
-#include "config.h"
-
 #include <stdarg.h>
 #include <stdbool.h>
 
--- dlls/amd_ags_x64/amd_ags_x64_main.c
+++ dlls/amd_ags_x64/amd_ags_x64_main.c
@@ -15,8 +15,29 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(amd_ags);
 
+enum amd_ags_version
+{
+    AMD_AGS_VERSION_5_1_1,
+    AMD_AGS_VERSION_5_2_0,
+
+    AMD_AGS_VERSION_COUNT
+};
+
+struct
+{
+    int major;
+    int minor;
+    int patch;
+}
+static const amd_ags_versions[AMD_AGS_VERSION_COUNT] =
+{
+    {5, 1, 1},
+    {5, 2, 0},
+};
+
 struct AGSContext
 {
+    enum amd_ags_version version;
     unsigned int device_count;
     AGSDeviceInfo *devices;
     VkPhysicalDeviceProperties *properties;
@@ -88,6 +109,8 @@ static AGSReturnCode init_ags_context(AGSContext *context)
     AGSReturnCode ret;
     unsigned int i;
 
+    // TODO: version check
+    context->version = AMD_AGS_VERSION_5_1_1;
     context->device_count = 0;
     context->devices = NULL;
     context->properties = NULL;
@@ -108,15 +131,32 @@ static AGSReturnCode init_ags_context(AGSContext *context)
         const VkPhysicalDeviceProperties *vk_properties = &context->properties[i];
         AGSDeviceInfo *device = &context->devices[i];
 
-        device->adapterString = vk_properties->deviceName;
-        device->vendorId = vk_properties->vendorID;
-        device->deviceId = vk_properties->deviceID;
+        switch (context->version)
+        {
+        case AMD_AGS_VERSION_5_1_1:
+            device->agsDeviceInfo511.adapterString = vk_properties->deviceName;
+            device->agsDeviceInfo511.vendorId = vk_properties->vendorID;
+            device->agsDeviceInfo511.deviceId = vk_properties->deviceID;
+
+            if (device->agsDeviceInfo511.vendorId == 0x1002)
+                device->agsDeviceInfo511.architectureVersion = ArchitectureVersion_GCN;
 
-        if (device->vendorId == 0x1002)
-            device->architectureVersion = ArchitectureVersion_GCN;
+            if (!i)
+                device->agsDeviceInfo511.isPrimaryDevice = 1;
+            break;
+        case AMD_AGS_VERSION_5_2_0:
+        default:
+            device->agsDeviceInfo520.adapterString = vk_properties->deviceName;
+            device->agsDeviceInfo520.vendorId = vk_properties->vendorID;
+            device->agsDeviceInfo520.deviceId = vk_properties->deviceID;
+
+            if (device->agsDeviceInfo520.vendorId == 0x1002)
+                device->agsDeviceInfo520.architectureVersion = ArchitectureVersion_GCN;
 
-        if (!i)
-            device->isPrimaryDevice = 1;
+            if (!i)
+                device->agsDeviceInfo520.isPrimaryDevice = 1;
+            break;
+        }
     }
 
     return AGS_SUCCESS;
@@ -145,9 +185,9 @@ AGSReturnCode WINAPI agsInit(AGSContext **context, const AGSConfiguration *confi
     }
 
     memset(gpu_info, 0, sizeof(*gpu_info));
-    gpu_info->agsVersionMajor = AMD_AGS_VERSION_MAJOR;
-    gpu_info->agsVersionMinor = AMD_AGS_VERSION_MINOR;
-    gpu_info->agsVersionPatch = AMD_AGS_VERSION_PATCH;
+    gpu_info->agsVersionMajor = amd_ags_versions[object->version].major;
+    gpu_info->agsVersionMinor = amd_ags_versions[object->version].minor;
+    gpu_info->agsVersionPatch = amd_ags_versions[object->version].patch;
     gpu_info->driverVersion = "18.10.16-180516a-328911C-RadeonSoftwareAdrenalin";
     gpu_info->radeonSoftwareVersion  = "18.5.1";
     gpu_info->numDevices = object->device_count;
--- dlls/amd_ags_x64/amd_ags_x64_main.c
+++ dlls/amd_ags_x64/amd_ags_x64_main.c
@@ -19,6 +19,7 @@ enum amd_ags_version
 {
     AMD_AGS_VERSION_5_1_1,
     AMD_AGS_VERSION_5_2_0,
+    AMD_AGS_VERSION_5_2_1,
 
     AMD_AGS_VERSION_COUNT
 };
@@ -33,6 +34,7 @@ static const amd_ags_versions[AMD_AGS_VERSION_COUNT] =
 {
     {5, 1, 1},
     {5, 2, 0},
+    {5, 2, 1},
 };
 
 struct AGSContext
@@ -145,6 +147,7 @@ static AGSReturnCode init_ags_context(AGSContext *context)
                 device->agsDeviceInfo511.isPrimaryDevice = 1;
             break;
         case AMD_AGS_VERSION_5_2_0:
+        case AMD_AGS_VERSION_5_2_1:
         default:
             device->agsDeviceInfo520.adapterString = vk_properties->deviceName;
             device->agsDeviceInfo520.vendorId = vk_properties->vendorID;
--- dlls/amd_ags_x64/amd_ags_x64_main.c
+++ dlls/amd_ags_x64/amd_ags_x64_main.c
@@ -20,6 +20,7 @@ enum amd_ags_version
     AMD_AGS_VERSION_5_1_1,
     AMD_AGS_VERSION_5_2_0,
     AMD_AGS_VERSION_5_2_1,
+    AMD_AGS_VERSION_5_3_0,
 
     AMD_AGS_VERSION_COUNT
 };
@@ -35,6 +36,7 @@ static const amd_ags_versions[AMD_AGS_VERSION_COUNT] =
     {5, 1, 1},
     {5, 2, 0},
     {5, 2, 1},
+    {5, 3, 0},
 };
 
 struct AGSContext
@@ -148,6 +150,7 @@ static AGSReturnCode init_ags_context(AGSContext *context)
             break;
         case AMD_AGS_VERSION_5_2_0:
         case AMD_AGS_VERSION_5_2_1:
+        case AMD_AGS_VERSION_5_3_0:
         default:
             device->agsDeviceInfo520.adapterString = vk_properties->deviceName;
             device->agsDeviceInfo520.vendorId = vk_properties->vendorID;
--- dlls/amd_ags_x64/amd_ags_x64_main.c
+++ dlls/amd_ags_x64/amd_ags_x64_main.c
@@ -21,6 +21,7 @@ enum amd_ags_version
     AMD_AGS_VERSION_5_2_0,
     AMD_AGS_VERSION_5_2_1,
     AMD_AGS_VERSION_5_3_0,
+    AMD_AGS_VERSION_5_4_0,
 
     AMD_AGS_VERSION_COUNT
 };
@@ -37,6 +38,7 @@ static const amd_ags_versions[AMD_AGS_VERSION_COUNT] =
     {5, 2, 0},
     {5, 2, 1},
     {5, 3, 0},
+    {5, 4, 0},
 };
 
 struct AGSContext
@@ -151,7 +153,6 @@ static AGSReturnCode init_ags_context(AGSContext *context)
         case AMD_AGS_VERSION_5_2_0:
         case AMD_AGS_VERSION_5_2_1:
         case AMD_AGS_VERSION_5_3_0:
-        default:
             device->agsDeviceInfo520.adapterString = vk_properties->deviceName;
             device->agsDeviceInfo520.vendorId = vk_properties->vendorID;
             device->agsDeviceInfo520.deviceId = vk_properties->deviceID;
--- dlls/amd_ags_x64/amd_ags_x64_main.c
+++ dlls/amd_ags_x64/amd_ags_x64_main.c
@@ -22,6 +22,7 @@ enum amd_ags_version
     AMD_AGS_VERSION_5_2_1,
     AMD_AGS_VERSION_5_3_0,
     AMD_AGS_VERSION_5_4_0,
+    AMD_AGS_VERSION_5_4_1,
 
     AMD_AGS_VERSION_COUNT
 };
@@ -39,6 +40,7 @@ static const amd_ags_versions[AMD_AGS_VERSION_COUNT] =
     {5, 2, 1},
     {5, 3, 0},
     {5, 4, 0},
+    {5, 4, 1},
 };
 
 struct AGSContext
@@ -164,7 +166,6 @@ static AGSReturnCode init_ags_context(AGSContext *context)
                 device->agsDeviceInfo520.isPrimaryDevice = 1;
             break;
         case AMD_AGS_VERSION_5_4_0:
-        default:
             device->agsDeviceInfo540.adapterString = vk_properties->deviceName;
             device->agsDeviceInfo540.vendorId = vk_properties->vendorID;
             device->agsDeviceInfo540.deviceId = vk_properties->deviceID;
@@ -175,6 +176,18 @@ static AGSReturnCode init_ags_context(AGSContext *context)
             if (!i)
                 device->agsDeviceInfo540.isPrimaryDevice = 1;
             break;
+        case AMD_AGS_VERSION_5_4_1:
+        default:
+            device->agsDeviceInfo541.adapterString = vk_properties->deviceName;
+            device->agsDeviceInfo541.vendorId = vk_properties->vendorID;
+            device->agsDeviceInfo541.deviceId = vk_properties->deviceID;
+
+            if (device->agsDeviceInfo541.vendorId == 0x1002)
+                device->agsDeviceInfo541.asicFamily = AsicFamily_GCN4;
+
+            if (!i)
+                device->agsDeviceInfo541.isPrimaryDevice = 1;
+            break;
         }
     }
 
--- dlls/amd_ags_x64/amd_ags_x64_main.c
+++ dlls/amd_ags_x64/amd_ags_x64_main.c
@@ -49,12 +49,14 @@ struct AGSContext
     unsigned int device_count;
     AGSDeviceInfo *devices;
     VkPhysicalDeviceProperties *properties;
+    VkPhysicalDeviceMemoryProperties *memory_properties;
 };
 
 static AGSReturnCode vk_get_physical_device_properties(unsigned int *out_count,
-        VkPhysicalDeviceProperties **out)
+        VkPhysicalDeviceProperties **out, VkPhysicalDeviceMemoryProperties **out_memory)
 {
     VkPhysicalDeviceProperties *properties = NULL;
+    VkPhysicalDeviceMemoryProperties *memory_properties = NULL;
     VkPhysicalDevice *vk_physical_devices = NULL;
     VkInstance vk_instance = VK_NULL_HANDLE;
     VkInstanceCreateInfo create_info;
@@ -99,11 +101,23 @@ static AGSReturnCode vk_get_physical_device_properties(unsigned int *out_count,
         goto done;
     }
 
+    if (!(memory_properties = heap_calloc(count, sizeof(*memory_properties))))
+    {
+        WARN("Failed to allocate memory.\n");
+        heap_free(properties);
+        ret = AGS_OUT_OF_MEMORY;
+        goto done;
+    }
+
     for (i = 0; i < count; ++i)
         vkGetPhysicalDeviceProperties(vk_physical_devices[i], &properties[i]);
 
+    for (i = 0; i < count; ++i)
+        vkGetPhysicalDeviceMemoryProperties(vk_physical_devices[i], &memory_properties[i]);
+
     *out_count = count;
     *out = properties;
+    *out_memory = memory_properties;
 
 done:
     heap_free(vk_physical_devices);
@@ -115,15 +129,16 @@ static AGSReturnCode vk_get_physical_device_properties(unsigned int *out_count,
 static AGSReturnCode init_ags_context(AGSContext *context)
 {
     AGSReturnCode ret;
-    unsigned int i;
+    unsigned int i, j;
 
     // TODO: version check
     context->version = AMD_AGS_VERSION_5_1_1;
     context->device_count = 0;
     context->devices = NULL;
     context->properties = NULL;
+    context->memory_properties = NULL;
 
-    ret = vk_get_physical_device_properties(&context->device_count, &context->properties);
+    ret = vk_get_physical_device_properties(&context->device_count, &context->properties, &context->memory_properties);
     if (ret != AGS_SUCCESS || !context->device_count)
         return ret;
 
@@ -131,13 +146,26 @@ static AGSReturnCode init_ags_context(AGSContext *context)
     {
         WARN("Failed to allocate memory.\n");
         heap_free(context->properties);
+        heap_free(context->memory_properties);
         return AGS_OUT_OF_MEMORY;
     }
 
     for (i = 0; i < context->device_count; ++i)
     {
         const VkPhysicalDeviceProperties *vk_properties = &context->properties[i];
+        const VkPhysicalDeviceMemoryProperties *vk_memory_properties = &context->memory_properties[i];
         AGSDeviceInfo *device = &context->devices[i];
+        VkDeviceSize local_memory_size = 0;
+
+        for (j = 0; j < vk_memory_properties->memoryHeapCount; j++)
+        {
+            if (vk_memory_properties->memoryHeaps[j].flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)
+            {
+                local_memory_size = vk_memory_properties->memoryHeaps[j].size;
+                break;
+            }
+        }
+        TRACE("reporting local memory size 0x%s bytes\n", wine_dbgstr_longlong(local_memory_size));
 
         switch (context->version)
         {
@@ -145,6 +173,7 @@ static AGSReturnCode init_ags_context(AGSContext *context)
             device->agsDeviceInfo511.adapterString = vk_properties->deviceName;
             device->agsDeviceInfo511.vendorId = vk_properties->vendorID;
             device->agsDeviceInfo511.deviceId = vk_properties->deviceID;
+            device->agsDeviceInfo511.localMemoryInBytes = local_memory_size;
 
             if (device->agsDeviceInfo511.vendorId == 0x1002)
                 device->agsDeviceInfo511.architectureVersion = ArchitectureVersion_GCN;
@@ -158,6 +187,7 @@ static AGSReturnCode init_ags_context(AGSContext *context)
             device->agsDeviceInfo520.adapterString = vk_properties->deviceName;
             device->agsDeviceInfo520.vendorId = vk_properties->vendorID;
             device->agsDeviceInfo520.deviceId = vk_properties->deviceID;
+            device->agsDeviceInfo520.localMemoryInBytes = local_memory_size;
 
             if (device->agsDeviceInfo520.vendorId == 0x1002)
                 device->agsDeviceInfo520.architectureVersion = ArchitectureVersion_GCN;
@@ -169,6 +199,7 @@ static AGSReturnCode init_ags_context(AGSContext *context)
             device->agsDeviceInfo540.adapterString = vk_properties->deviceName;
             device->agsDeviceInfo540.vendorId = vk_properties->vendorID;
             device->agsDeviceInfo540.deviceId = vk_properties->deviceID;
+            device->agsDeviceInfo540.localMemoryInBytes = local_memory_size;
 
             if (device->agsDeviceInfo540.vendorId == 0x1002)
                 device->agsDeviceInfo540.asicFamily = AsicFamily_GCN4;
@@ -181,6 +212,7 @@ static AGSReturnCode init_ags_context(AGSContext *context)
             device->agsDeviceInfo541.adapterString = vk_properties->deviceName;
             device->agsDeviceInfo541.vendorId = vk_properties->vendorID;
             device->agsDeviceInfo541.deviceId = vk_properties->deviceID;
+            device->agsDeviceInfo541.localMemoryInBytes = local_memory_size;
 
             if (device->agsDeviceInfo541.vendorId == 0x1002)
                 device->agsDeviceInfo541.asicFamily = AsicFamily_GCN4;
@@ -238,6 +270,7 @@ AGSReturnCode WINAPI agsDeInit(AGSContext *context)
 
     if (context)
     {
+        heap_free(context->memory_properties);
         heap_free(context->properties);
         heap_free(context->devices);
         heap_free(context);
--- dlls/amd_ags_x64/amd_ags_x64_main.c
+++ dlls/amd_ags_x64/amd_ags_x64_main.c
@@ -252,8 +252,8 @@ AGSReturnCode WINAPI agsInit(AGSContext **context, const AGSConfiguration *confi
     gpu_info->agsVersionMajor = amd_ags_versions[object->version].major;
     gpu_info->agsVersionMinor = amd_ags_versions[object->version].minor;
     gpu_info->agsVersionPatch = amd_ags_versions[object->version].patch;
-    gpu_info->driverVersion = "18.10.16-180516a-328911C-RadeonSoftwareAdrenalin";
-    gpu_info->radeonSoftwareVersion  = "18.5.1";
+    gpu_info->driverVersion = "20.20.2-180516a-328911C-RadeonSoftwareAdrenalin";
+    gpu_info->radeonSoftwareVersion  = "20.20.2";
     gpu_info->numDevices = object->device_count;
     gpu_info->devices = object->devices;
 
--- dlls/amd_ags_x64/amd_ags_x64_main.c
+++ dlls/amd_ags_x64/amd_ags_x64_main.c
@@ -126,13 +126,79 @@ static AGSReturnCode vk_get_physical_device_properties(unsigned int *out_count,
     return ret;
 }
 
+static enum amd_ags_version determine_ags_version(void)
+{
+    /* AMD AGS is not binary compatible between versions (even minor versions), and the game
+     * does not request a specific version when calling agsInit().
+     * Checking the version of amd_ags_x64.dll shipped with the game is the only way to
+     * determine what version the game was built against.
+     *
+     * An update to AGS 5.4.1 included an amd_ags_x64.dll with no file version info.
+     * In case of an error, assume it's that version.
+     */
+    enum amd_ags_version ret = AMD_AGS_VERSION_5_4_1;
+    DWORD infosize;
+    void *infobuf = NULL;
+    void *val;
+    UINT vallen, i;
+    VS_FIXEDFILEINFO *info;
+    UINT16 major, minor, patch;
+
+    infosize = GetFileVersionInfoSizeW(L"amd_ags_x64.dll", NULL);
+    if (!infosize)
+    {
+        WARN("Unable to determine desired version of amd_ags_x64.dll.\n");
+        goto done;
+    }
+
+    if (!(infobuf = heap_alloc(infosize)))
+    {
+        WARN("Failed to allocate memory.\n");
+        goto done;
+    }
+
+    if (!GetFileVersionInfoW(L"amd_ags_x64.dll", 0, infosize, infobuf))
+    {
+        WARN("Unable to determine desired version of amd_ags_x64.dll.\n");
+        goto done;
+    }
+
+    if (!VerQueryValueW(infobuf, L"\\", &val, &vallen) || (vallen != sizeof(VS_FIXEDFILEINFO)))
+    {
+        WARN("Unable to determine desired version of amd_ags_x64.dll.\n");
+        goto done;
+    }
+
+    info = val;
+    major = info->dwFileVersionMS >> 16;
+    minor = info->dwFileVersionMS;
+    patch = info->dwFileVersionLS >> 16;
+    TRACE("Found amd_ags_x64.dll v%d.%d.%d\n", major, minor, patch);
+
+    for (i = 0; i < ARRAY_SIZE(amd_ags_versions); i++)
+    {
+        if ((major == amd_ags_versions[i].major) &&
+            (minor == amd_ags_versions[i].minor) &&
+            (patch == amd_ags_versions[i].patch))
+        {
+            ret = i;
+            break;
+        }
+    }
+
+done:
+    heap_free(infobuf);
+    TRACE("Using AGS v%d.%d.%d interface\n",
+          amd_ags_versions[ret].major, amd_ags_versions[ret].minor, amd_ags_versions[ret].patch);
+    return ret;
+}
+
 static AGSReturnCode init_ags_context(AGSContext *context)
 {
     AGSReturnCode ret;
     unsigned int i, j;
 
-    // TODO: version check
-    context->version = AMD_AGS_VERSION_5_1_1;
+    context->version = determine_ags_version();
     context->device_count = 0;
     context->devices = NULL;
     context->properties = NULL;
