--- dlls/winegstreamer/colorconvert.c
+++ dlls/winegstreamer/colorconvert.c
@@ -26,6 +26,24 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+static const GUID *raw_types[] = {
+    &MFVideoFormat_RGB24,
+    &MFVideoFormat_RGB32,
+    &MFVideoFormat_RGB555,
+    &MFVideoFormat_RGB8,
+    &MFVideoFormat_AYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_NV11,
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_UYVY,
+    &MFVideoFormat_v216,
+    &MFVideoFormat_v410,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_YVYU,
+    &MFVideoFormat_YVYU,
+};
+
 struct color_converter
 {
     IMFTransform IMFTransform_iface;
@@ -160,9 +178,35 @@ static HRESULT WINAPI color_converter_AddInputStreams(IMFTransform *iface, DWORD
 static HRESULT WINAPI color_converter_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+    IMFMediaType *ret;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= ARRAY_SIZE(raw_types))
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_SUBTYPE, raw_types[index])))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    *type = ret;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI color_converter_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
--- dlls/winegstreamer/colorconvert.c
+++ dlls/winegstreamer/colorconvert.c
@@ -48,6 +48,8 @@ struct color_converter
 {
     IMFTransform IMFTransform_iface;
     LONG refcount;
+    IMFMediaType *input_type;
+    CRITICAL_SECTION cs;
 };
 
 static struct color_converter *impl_color_converter_from_IMFTransform(IMFTransform *iface)
@@ -91,6 +93,8 @@ static ULONG WINAPI color_converter_Release(IMFTransform *iface)
 
     if (!refcount)
     {
+        transform->cs.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&transform->cs);
         free(transform);
     }
 
@@ -219,9 +223,73 @@ static HRESULT WINAPI color_converter_GetOutputAvailableType(IMFTransform *iface
 
 static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    GUID major_type, subtype;
+    unsigned int i;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&converter->cs);
+
+        if (converter->input_type)
+        {
+            IMFMediaType_Release(converter->input_type);
+            converter->input_type = NULL;
+        }
+
+        LeaveCriticalSection(&converter->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!IsEqualGUID(&major_type, &MFMediaType_Video))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < ARRAY_SIZE(raw_types); i++)
+    {
+        if (IsEqualGUID(&subtype, raw_types[i]))
+            break;
+    }
+
+    if (i == ARRAY_SIZE(raw_types))
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&converter->cs);
+
+    hr = S_OK;
+
+    if (!converter->input_type)
+        hr = MFCreateMediaType(&converter->input_type);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) converter->input_type);
+
+    if (FAILED(hr))
+    {
+        IMFMediaType_Release(converter->input_type);
+        converter->input_type = NULL;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
--- dlls/winegstreamer/colorconvert.c
+++ dlls/winegstreamer/colorconvert.c
@@ -216,9 +216,43 @@ static HRESULT WINAPI color_converter_GetInputAvailableType(IMFTransform *iface,
 static HRESULT WINAPI color_converter_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFMediaType *ret;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= ARRAY_SIZE(raw_types))
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+        IMFMediaType_CopyAllItems(converter->input_type, (IMFAttributes *) ret);
+
+    LeaveCriticalSection(&converter->cs);
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_SUBTYPE, raw_types[index])))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    *type = ret;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
--- dlls/winegstreamer/colorconvert.c
+++ dlls/winegstreamer/colorconvert.c
@@ -49,6 +49,7 @@ struct color_converter
     IMFTransform IMFTransform_iface;
     LONG refcount;
     IMFMediaType *input_type;
+    IMFMediaType *output_type;
     CRITICAL_SECTION cs;
 };
 
@@ -95,6 +96,8 @@ static ULONG WINAPI color_converter_Release(IMFTransform *iface)
     {
         transform->cs.DebugInfo->Spare[0] = 0;
         DeleteCriticalSection(&transform->cs);
+        if (transform->output_type)
+            IMFMediaType_Release(transform->output_type);
         free(transform);
     }
 
@@ -258,6 +261,7 @@ static HRESULT WINAPI color_converter_GetOutputAvailableType(IMFTransform *iface
 static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 input_framesize, output_framesize;
     GUID major_type, subtype;
     unsigned int i;
     HRESULT hr;
@@ -302,6 +306,19 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
     if (i == ARRAY_SIZE(raw_types))
         return MF_E_INVALIDTYPE;
 
+    EnterCriticalSection(&converter->cs);
+
+    if(converter->output_type
+         && SUCCEEDED(IMFMediaType_GetUINT64(converter->output_type, &MF_MT_FRAME_SIZE, &output_framesize))
+         && SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &input_framesize))
+         && input_framesize != output_framesize)
+    {
+        LeaveCriticalSection(&converter->cs);
+        return MF_E_INVALIDTYPE;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
@@ -328,9 +345,87 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
 
 static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 input_framesize, output_framesize;
+    GUID major_type, subtype;
+    unsigned int i;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&converter->cs);
+
+        if (converter->output_type)
+        {
+            IMFMediaType_Release(converter->output_type);
+            converter->output_type = NULL;
+        }
+
+        LeaveCriticalSection(&converter->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!IsEqualGUID(&major_type, &MFMediaType_Video))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < ARRAY_SIZE(raw_types); i++)
+    {
+        if (IsEqualGUID(&subtype, raw_types[i]))
+            break;
+    }
+
+    if (i == ARRAY_SIZE(raw_types))
+        return MF_E_INVALIDTYPE;
+
+    EnterCriticalSection(&converter->cs);
+
+    if(converter->input_type
+         && SUCCEEDED(IMFMediaType_GetUINT64(converter->input_type, &MF_MT_FRAME_SIZE, &input_framesize))
+         && SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &output_framesize))
+         && input_framesize != output_framesize)
+    {
+        LeaveCriticalSection(&converter->cs);
+        return MF_E_INVALIDTYPE;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&converter->cs);
+
+    hr = S_OK;
+
+    if (!converter->output_type)
+        hr = MFCreateMediaType(&converter->output_type);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) converter->output_type);
+
+    if (FAILED(hr))
+    {
+        IMFMediaType_Release(converter->output_type);
+        converter->output_type = NULL;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI color_converter_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
--- dlls/winegstreamer/colorconvert.c
+++ dlls/winegstreamer/colorconvert.c
@@ -51,6 +51,10 @@ struct color_converter
     IMFMediaType *input_type;
     IMFMediaType *output_type;
     CRITICAL_SECTION cs;
+    BOOL buffer_inflight;
+    LONGLONG buffer_pts, buffer_dur;
+    struct wg_parser *parser;
+    struct wg_parser_stream *stream;
 };
 
 static struct color_converter *impl_color_converter_from_IMFTransform(IMFTransform *iface)
@@ -98,6 +102,10 @@ static ULONG WINAPI color_converter_Release(IMFTransform *iface)
         DeleteCriticalSection(&transform->cs);
         if (transform->output_type)
             IMFMediaType_Release(transform->output_type);
+        if (transform->stream)
+            unix_funcs->wg_parser_disconnect(transform->parser);
+        if (transform->parser)
+            unix_funcs->wg_parser_destroy(transform->parser);
         free(transform);
     }
 
@@ -263,6 +271,7 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
     struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
     UINT64 input_framesize, output_framesize;
     GUID major_type, subtype;
+    struct wg_format format;
     unsigned int i;
     HRESULT hr;
 
@@ -280,6 +289,11 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
 
         if (converter->input_type)
         {
+            if (converter->stream)
+            {
+                unix_funcs->wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
             IMFMediaType_Release(converter->input_type);
             converter->input_type = NULL;
         }
@@ -319,6 +333,10 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
 
     LeaveCriticalSection(&converter->cs);
 
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
@@ -338,6 +356,21 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
         converter->input_type = NULL;
     }
 
+    if (converter->stream)
+    {
+        unix_funcs->wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format output_format;
+        mf_media_type_to_wg_format(converter->output_type, &output_format);
+
+        if (SUCCEEDED(hr = unix_funcs->wg_parser_connect_unseekable(converter->parser, &format, 1, &output_format, NULL)))
+            converter->stream = unix_funcs->wg_parser_get_stream(converter->parser, 0);
+    }
+
     LeaveCriticalSection(&converter->cs);
 
     return hr;
@@ -348,6 +381,7 @@ static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD i
     struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
     UINT64 input_framesize, output_framesize;
     GUID major_type, subtype;
+    struct wg_format format;
     unsigned int i;
     HRESULT hr;
 
@@ -365,6 +399,11 @@ static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD i
 
         if (converter->output_type)
         {
+            if (converter->stream)
+            {
+                unix_funcs->wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
             IMFMediaType_Release(converter->output_type);
             converter->output_type = NULL;
         }
@@ -404,6 +443,10 @@ static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD i
 
     LeaveCriticalSection(&converter->cs);
 
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
@@ -423,9 +466,24 @@ static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD i
         converter->output_type = NULL;
     }
 
+    if (converter->stream)
+    {
+        unix_funcs->wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format input_format;
+        mf_media_type_to_wg_format(converter->input_type, &input_format);
+
+        if (SUCCEEDED(hr = unix_funcs->wg_parser_connect_unseekable(converter->parser, &input_format, 1, &format, NULL)))
+            converter->stream = unix_funcs->wg_parser_get_stream(converter->parser, 0);
+    }
+
     LeaveCriticalSection(&converter->cs);
 
-    return S_OK;
+    return hr;
 }
 
 static HRESULT WINAPI color_converter_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
@@ -479,17 +537,221 @@ static HRESULT WINAPI color_converter_ProcessMessage(IMFTransform *iface, MFT_ME
 
 static HRESULT WINAPI color_converter_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_size;
+    uint64_t offset;
+    uint32_t size;
+    void *data;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (converter->buffer_inflight)
+    {
+        hr = MF_E_NOTACCEPTING;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, &buffer_size)))
+        goto done;
+
+    for (;;)
+    {
+        if (!unix_funcs->wg_parser_get_read_request(converter->parser, &data, &offset, &size))
+            continue;
+
+        memcpy(data, buffer_data, min(buffer_size, size));
+
+        unix_funcs->wg_parser_complete_read_request(converter->parser, WG_READ_SUCCESS, buffer_size);
+
+        if (buffer_size <= size)
+            break;
+
+        buffer_data += size;
+        buffer_size -= size;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+    converter->buffer_inflight = TRUE;
+    if (FAILED(IMFSample_GetSampleTime(sample, &converter->buffer_pts)))
+        converter->buffer_pts = -1;
+    if (FAILED(IMFSample_GetSampleDuration(sample, &converter->buffer_dur)))
+        converter->buffer_dur = -1;
+
+done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    LeaveCriticalSection(&converter->cs);
+    return hr;
 }
 
 static HRESULT WINAPI color_converter_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFSample *allocated_sample = NULL;
+    IMFMediaBuffer *buffer = NULL;
+    struct wg_parser_event event;
+    unsigned char *buffer_data;
+    DWORD buffer_len;
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (!count)
+        return S_OK;
+
+    if (count != 1)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (samples[0].dwStreamID != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (!converter->buffer_inflight)
+    {
+        hr = MF_E_TRANSFORM_NEED_MORE_INPUT;
+        goto done;
+    }
+
+    for (;;)
+    {
+        unix_funcs->wg_parser_stream_get_event(converter->stream, &event);
+
+        switch (event.type)
+        {
+            case WG_PARSER_EVENT_BUFFER:
+                break;
+
+            case WG_PARSER_EVENT_SEGMENT:
+                continue;
+
+            default:
+                WARN("Unexpected event, %u\n", event.type);
+                continue;
+        }
+        break;
+    }
+
+    if (!samples[0].pSample)
+    {
+        if (FAILED(hr = MFCreateMemoryBuffer(event.u.buffer.size, &buffer)))
+        {
+            ERR("Failed to create buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        if (FAILED(hr = MFCreateSample(&allocated_sample)))
+        {
+            ERR("Failed to create sample, hr %#x.\n", hr);
+            goto done;
+        }
+
+        samples[0].pSample = allocated_sample;
+
+        if (FAILED(hr = IMFSample_AddBuffer(samples[0].pSample, buffer)))
+        {
+            ERR("Failed to add buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        IMFMediaBuffer_Release(buffer);
+        buffer = NULL;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &buffer)))
+    {
+        ERR("Failed to get buffer from sample, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_GetMaxLength(buffer, &buffer_len)))
+    {
+        ERR("Failed to get buffer size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (buffer_len < event.u.buffer.size)
+    {
+        WARN("Client's buffer is smaller (%u bytes) than the output sample (%u bytes)\n",
+            buffer_len, event.u.buffer.size);
+
+        hr = MF_E_BUFFERTOOSMALL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, event.u.buffer.size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (!unix_funcs->wg_parser_stream_copy_buffer(converter->stream, buffer_data, 0, event.u.buffer.size))
+    {
+        ERR("Failed to copy buffer.\n");
+        IMFMediaBuffer_Unlock(buffer);
+        hr = E_FAIL;
+        goto done;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+
+    unix_funcs->wg_parser_stream_release_buffer(converter->stream);
+    converter->buffer_inflight = FALSE;
+
+    if (converter->buffer_pts != -1)
+        IMFSample_SetSampleTime(samples[0].pSample, converter->buffer_pts);
+    if (converter->buffer_dur != -1)
+        IMFSample_SetSampleDuration(samples[0].pSample, converter->buffer_dur);
+
+    samples[0].dwStatus = 0;
+    samples[0].pEvents = NULL;
+
+    done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    if (FAILED(hr) && allocated_sample)
+    {
+        IMFSample_Release(allocated_sample);
+        samples[0].pSample = NULL;
+    }
+    LeaveCriticalSection(&converter->cs);
+    return hr;
 }
 
 static const IMFTransformVtbl color_converter_vtbl =
@@ -537,6 +799,13 @@ HRESULT color_converter_create(REFIID riid, void **ret)
     InitializeCriticalSection(&object->cs);
     object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": color_converter_lock");
 
+    if (!(object->parser = unix_funcs->wg_raw_media_converter_create()))
+    {
+        ERR("Failed to create video converter due to GStreamer error.\n");
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return E_OUTOFMEMORY;
+    }
+
     *ret = &object->IMFTransform_iface;
     return S_OK;
 }
--- dlls/winegstreamer/colorconvert.c
+++ dlls/winegstreamer/colorconvert.c
@@ -530,9 +530,17 @@ static HRESULT WINAPI color_converter_ProcessEvent(IMFTransform *iface, DWORD id
 
 static HRESULT WINAPI color_converter_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
-    FIXME("%p, %u %lu.\n", iface, message, param);
+    TRACE("%p, %u %lu.\n", iface, message, param);
 
-    return E_NOTIMPL;
+    switch(message)
+    {
+        case MFT_MESSAGE_COMMAND_FLUSH:
+        case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+            return S_OK;
+        default:
+            FIXME("Unhandled message type %x.\n", message);
+            return E_NOTIMPL;
+    }
 }
 
 static HRESULT WINAPI color_converter_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
--- dlls/winegstreamer/colorconvert.c
+++ dlls/winegstreamer/colorconvert.c
@@ -141,16 +141,72 @@ static HRESULT WINAPI color_converter_GetStreamIDs(IMFTransform *iface, DWORD in
 
 static HRESULT WINAPI color_converter_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
-    FIXME("%p %u %p.\n", iface, id, info);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 framesize;
+    GUID subtype;
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_DOES_NOT_ADDREF | MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+    info->hnsMaxLatency = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+    {
+        if (SUCCEEDED(IMFMediaType_GetGUID(converter->input_type, &MF_MT_SUBTYPE, &subtype)) &&
+            SUCCEEDED(IMFMediaType_GetUINT64(converter->input_type, &MF_MT_FRAME_SIZE, &framesize)))
+        {
+            MFCalculateImageSize(&subtype, framesize >> 32, (UINT32) framesize, &info->cbSize);
+        }
+
+        if (!info->cbSize)
+            WARN("Failed to get desired input buffer size, the non-provided sample path will likely break\n");
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI color_converter_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
 {
-    FIXME("%p %u %p.\n", iface, id, info);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 framesize;
+    GUID subtype;
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES | MFT_OUTPUT_STREAM_WHOLE_SAMPLES | MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER;
+    info->cbAlignment = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->output_type)
+    {
+        if (SUCCEEDED(IMFMediaType_GetGUID(converter->output_type, &MF_MT_SUBTYPE, &subtype)) &&
+            SUCCEEDED(IMFMediaType_GetUINT64(converter->output_type, &MF_MT_FRAME_SIZE, &framesize)))
+        {
+            MFCalculateImageSize(&subtype, framesize >> 32, (UINT32) framesize, &info->cbSize);
+        }
+
+        if (!info->cbSize)
+            WARN("Failed to get desired output buffer size, the non-provided sample path will likely break\n");
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI color_converter_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
--- dlls/winegstreamer/colorconvert.c
+++ dlls/winegstreamer/colorconvert.c
@@ -586,11 +586,31 @@ static HRESULT WINAPI color_converter_ProcessEvent(IMFTransform *iface, DWORD id
 
 static HRESULT WINAPI color_converter_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    struct wg_parser_event event;
+
     TRACE("%p, %u %lu.\n", iface, message, param);
 
     switch(message)
     {
         case MFT_MESSAGE_COMMAND_FLUSH:
+        {
+            EnterCriticalSection(&converter->cs);
+            if (!converter->buffer_inflight)
+            {
+                LeaveCriticalSection(&converter->cs);
+                return S_OK;
+            }
+
+            while (event.type != WG_PARSER_EVENT_BUFFER)
+                unix_funcs->wg_parser_stream_get_event(converter->stream, &event);
+
+            unix_funcs->wg_parser_stream_release_buffer(converter->stream);
+            converter->buffer_inflight = FALSE;
+
+            LeaveCriticalSection(&converter->cs);
+            return S_OK;
+        }
         case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
             return S_OK;
         default:
@@ -641,7 +661,10 @@ static HRESULT WINAPI color_converter_ProcessInput(IMFTransform *iface, DWORD id
     for (;;)
     {
         if (!unix_funcs->wg_parser_get_read_request(converter->parser, &data, &offset, &size))
+        {
+            TRACE("sink unconnected\n");
             continue;
+        }
 
         memcpy(data, buffer_data, min(buffer_size, size));
 
