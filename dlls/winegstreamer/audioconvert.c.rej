--- dlls/winegstreamer/audioconvert.c
+++ dlls/winegstreamer/audioconvert.c
@@ -35,6 +35,10 @@ struct audio_converter
     IMFMediaType *input_type;
     IMFMediaType *output_type;
     CRITICAL_SECTION cs;
+    BOOL buffer_inflight;
+    LONGLONG buffer_pts, buffer_dur;
+    struct wg_parser *parser;
+    struct wg_parser_stream *stream;
 };
 
 static struct audio_converter *impl_audio_converter_from_IMFTransform(IMFTransform *iface)
@@ -80,6 +84,10 @@ static ULONG WINAPI audio_converter_Release(IMFTransform *iface)
     {
         transform->cs.DebugInfo->Spare[0] = 0;
         DeleteCriticalSection(&transform->cs);
+        if (transform->stream)
+            unix_funcs->wg_parser_disconnect(transform->parser);
+        if (transform->parser)
+            unix_funcs->wg_parser_destroy(transform->parser);
         free(transform);
     }
 
@@ -272,6 +280,7 @@ fail:
 static HRESULT WINAPI audio_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     GUID major_type, subtype;
+    struct wg_format format;
     DWORD unused;
     HRESULT hr;
 
@@ -291,6 +300,11 @@ static HRESULT WINAPI audio_converter_SetInputType(IMFTransform *iface, DWORD id
 
         if (converter->input_type)
         {
+            if (converter->stream)
+            {
+                unix_funcs->wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
             IMFMediaType_Release(converter->input_type);
             converter->input_type = NULL;
         }
@@ -364,6 +397,7 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
 {
     struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
     GUID major_type, subtype;
+    struct wg_format format;
     DWORD unused;
     HRESULT hr;
 
@@ -372,9 +406,6 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
 
-    if (!converter->input_type)
-        return MF_E_TRANSFORM_TYPE_NOT_SET;
-
     if (!type)
     {
         if (flags & MFT_SET_TYPE_TEST_ONLY)
@@ -384,6 +415,11 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
 
         if (converter->output_type)
         {
+            if (converter->stream)
+            {
+                unix_funcs->wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
             IMFMediaType_Release(converter->output_type);
             converter->output_type = NULL;
         }
@@ -559,17 +614,221 @@ static HRESULT WINAPI audio_converter_ProcessMessage(IMFTransform *iface, MFT_ME
 
 static HRESULT WINAPI audio_converter_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_size;
+    uint64_t offset;
+    uint32_t size;
+    void *data;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (converter->buffer_inflight)
+    {
+        hr = MF_E_NOTACCEPTING;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, &buffer_size)))
+        goto done;
+
+    for (;;)
+    {
+        if (!unix_funcs->wg_parser_get_read_request(converter->parser, &data, &offset, &size))
+            continue;
+
+        memcpy(data, buffer_data, min(buffer_size, size));
+
+        unix_funcs->wg_parser_complete_read_request(converter->parser, WG_READ_SUCCESS, buffer_size);
+
+        if (buffer_size <= size)
+            break;
+
+        buffer_data += size;
+        buffer_size -= size;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+    converter->buffer_inflight = TRUE;
+    if (FAILED(IMFSample_GetSampleTime(sample, &converter->buffer_pts)))
+        converter->buffer_pts = -1;
+    if (FAILED(IMFSample_GetSampleDuration(sample, &converter->buffer_dur)))
+        converter->buffer_dur = -1;
+
+done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    LeaveCriticalSection(&converter->cs);
+    return hr;
 }
 
 static HRESULT WINAPI audio_converter_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    IMFSample *allocated_sample = NULL;
+    IMFMediaBuffer *buffer = NULL;
+    struct wg_parser_event event;
+    unsigned char *buffer_data;
+    DWORD buffer_len;
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (!count)
+        return S_OK;
+
+    if (count != 1)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (samples[0].dwStreamID != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (!converter->buffer_inflight)
+    {
+        hr = MF_E_TRANSFORM_NEED_MORE_INPUT;
+        goto done;
+    }
+
+    for (;;)
+    {
+        unix_funcs->wg_parser_stream_get_event(converter->stream, &event);
+
+        switch (event.type)
+        {
+            case WG_PARSER_EVENT_BUFFER:
+                break;
+
+            case WG_PARSER_EVENT_SEGMENT:
+                continue;
+
+            default:
+                WARN("Unexpected event, %u\n", event.type);
+                continue;
+        }
+        break;
+    }
+
+    if (!samples[0].pSample)
+    {
+        if (FAILED(hr = MFCreateMemoryBuffer(event.u.buffer.size, &buffer)))
+        {
+            ERR("Failed to create buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        if (FAILED(hr = MFCreateSample(&allocated_sample)))
+        {
+            ERR("Failed to create sample, hr %#x.\n", hr);
+            goto done;
+        }
+
+        samples[0].pSample = allocated_sample;
+
+        if (FAILED(hr = IMFSample_AddBuffer(samples[0].pSample, buffer)))
+        {
+            ERR("Failed to add buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        IMFMediaBuffer_Release(buffer);
+        buffer = NULL;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &buffer)))
+    {
+        ERR("Failed to get buffer from sample, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_GetMaxLength(buffer, &buffer_len)))
+    {
+        ERR("Failed to get buffer size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (buffer_len < event.u.buffer.size)
+    {
+        WARN("Client's buffer is smaller (%u bytes) than the output sample (%u bytes)\n",
+            buffer_len, event.u.buffer.size);
+
+        hr = MF_E_BUFFERTOOSMALL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, event.u.buffer.size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (!unix_funcs->wg_parser_stream_copy_buffer(converter->stream, buffer_data, 0, event.u.buffer.size))
+    {
+        ERR("Failed to copy buffer.\n");
+        IMFMediaBuffer_Unlock(buffer);
+        hr = E_FAIL;
+        goto done;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+
+    unix_funcs->wg_parser_stream_release_buffer(converter->stream);
+    converter->buffer_inflight = FALSE;
+
+    if (converter->buffer_pts != -1)
+        IMFSample_SetSampleTime(samples[0].pSample, converter->buffer_pts);
+    if (converter->buffer_dur != -1)
+        IMFSample_SetSampleDuration(samples[0].pSample, converter->buffer_dur);
+
+    samples[0].dwStatus = 0;
+    samples[0].pEvents = NULL;
+
+    done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    if (allocated_sample && FAILED(hr))
+    {
+        IMFSample_Release(allocated_sample);
+        samples[0].pSample = NULL;
+    }
+    LeaveCriticalSection(&converter->cs);
+    return hr;
 }
 
 static const IMFTransformVtbl audio_converter_vtbl =
--- dlls/winegstreamer/audioconvert.c
+++ dlls/winegstreamer/audioconvert.c
@@ -123,16 +123,50 @@ static HRESULT WINAPI audio_converter_GetStreamIDs(IMFTransform *iface, DWORD in
 
 static HRESULT WINAPI audio_converter_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
-    FIXME("%p %u %p.\n", iface, id, info);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_DOES_NOT_ADDREF;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+    info->hnsMaxLatency = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+        IMFMediaType_GetUINT32(converter->input_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &info->cbSize);
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
 {
-    FIXME("%p %u %p.\n", iface, id, info);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES | MFT_OUTPUT_STREAM_WHOLE_SAMPLES;
+    info->cbAlignment = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->output_type)
+        IMFMediaType_GetUINT32(converter->output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &info->cbSize);
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
--- dlls/winegstreamer/audioconvert.c
+++ dlls/winegstreamer/audioconvert.c
@@ -39,6 +39,7 @@ struct audio_converter
     LONGLONG buffer_pts, buffer_dur;
     struct wg_parser *parser;
     struct wg_parser_stream *stream;
+    IMFAttributes *attributes, *output_attributes;
 };
 
 static struct audio_converter *impl_audio_converter_from_IMFTransform(IMFTransform *iface)
@@ -84,6 +85,10 @@ static ULONG WINAPI audio_converter_Release(IMFTransform *iface)
     {
         transform->cs.DebugInfo->Spare[0] = 0;
         DeleteCriticalSection(&transform->cs);
+        if (transform->attributes)
+            IMFAttributes_Release(transform->attributes);
+        if (transform->output_attributes)
+            IMFAttributes_Release(transform->output_attributes);
         if (transform->stream)
             unix_funcs->wg_parser_disconnect(transform->parser);
         if (transform->parser)
@@ -171,9 +176,14 @@ static HRESULT WINAPI audio_converter_GetOutputStreamInfo(IMFTransform *iface, D
 
 static HRESULT WINAPI audio_converter_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
 {
-    FIXME("%p, %p.\n", iface, attributes);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, attributes);
+
+    *attributes = converter->attributes;
+    IMFAttributes_AddRef(*attributes);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
@@ -187,9 +197,17 @@ static HRESULT WINAPI audio_converter_GetInputStreamAttributes(IMFTransform *ifa
 static HRESULT WINAPI audio_converter_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
         IMFAttributes **attributes)
 {
-    FIXME("%p, %u, %p.\n", iface, id, attributes);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p.\n", iface, id, attributes);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    *attributes = converter->output_attributes;
+    IMFAttributes_AddRef(*attributes);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_DeleteInputStream(IMFTransform *iface, DWORD id)
@@ -860,6 +878,7 @@ static const IMFTransformVtbl audio_converter_vtbl =
 HRESULT audio_converter_create(REFIID riid, void **ret)
 {
     struct audio_converter *object;
+    HRESULT hr;
 
     TRACE("%s %p\n", debugstr_guid(riid), ret);
 
@@ -872,6 +891,18 @@ HRESULT audio_converter_create(REFIID riid, void **ret)
     InitializeCriticalSection(&object->cs);
     object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": audio_converter_lock");
 
+    if (FAILED(hr = MFCreateAttributes(&object->attributes, 0)))
+    {
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return hr;
+    }
+
+    if (FAILED(hr = MFCreateAttributes(&object->output_attributes, 0)))
+    {
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return hr;
+    }
+
     if (!(object->parser = unix_funcs->wg_raw_media_converter_create()))
     {
         ERR("Failed to create audio converter due to GStreamer error.\n");
--- dlls/winegstreamer/audioconvert.c
+++ dlls/winegstreamer/audioconvert.c
@@ -618,6 +618,7 @@ static HRESULT WINAPI audio_converter_ProcessMessage(IMFTransform *iface, MFT_ME
 
     switch(message)
     {
+        case MFT_MESSAGE_COMMAND_FLUSH:
         case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
             return S_OK;
         default:
--- dlls/winegstreamer/audioconvert.c
+++ dlls/winegstreamer/audioconvert.c
@@ -614,11 +614,31 @@ static HRESULT WINAPI audio_converter_ProcessEvent(IMFTransform *iface, DWORD id
 
 static HRESULT WINAPI audio_converter_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    struct wg_parser_event event;
+
     TRACE("%p, %u %lu.\n", iface, message, param);
 
     switch(message)
     {
         case MFT_MESSAGE_COMMAND_FLUSH:
+        {
+            EnterCriticalSection(&converter->cs);
+            if (!converter->buffer_inflight)
+            {
+                LeaveCriticalSection(&converter->cs);
+                return S_OK;
+            }
+
+            while (event.type != WG_PARSER_EVENT_BUFFER)
+                unix_funcs->wg_parser_stream_get_event(converter->stream, &event);
+
+            unix_funcs->wg_parser_stream_release_buffer(converter->stream);
+            converter->buffer_inflight = FALSE;
+
+            LeaveCriticalSection(&converter->cs);
+            return S_OK;
+        }
         case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
             return S_OK;
         default:
